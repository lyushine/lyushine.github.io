<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>前端者</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="前端者">
<meta property="og:url" content="http://www.qianduaner.com/page/3/index.html">
<meta property="og:site_name" content="前端者">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="前端者">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="前端者" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
      <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css" type="text/css">
  
  
      <link href="//cdn.bootcss.com/jqueryui/1.10.4/css/jquery-ui.min.css" rel="stylesheet">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css" type="text/css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
    
    
  
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: true,
          isPost: false,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false,
      }
  </script>

  
      <script>
          yiliaConfig.rootUrl = "/";
      </script>
  

  
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">前端者</a></h1>
        </hgroup>

        
                


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                            <li><a href="/links/">友情链接</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <li id="Email"><a class="Email" target="_blank" href="mailto:lyushine@qq.com" title="Email"></a></li>
                            
                                <li id="GitHub"><a class="GitHub" target="_blank" href="/#" title="GitHub"></a></li>
                            
                                <li id="RSS"><a class="RSS" target="_blank" href="/atom.xml" title="RSS"></a></li>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/lyushine">GitHub</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">专注于前端</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">前端者</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">前端者</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                    <li><a href="/links/">友情链接</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <li id="Email"><a class="Email" target="_blank" href="mailto:lyushine@qq.com" title="Email"></a></li>
                            
                                <li id="GitHub"><a class="GitHub" target="_blank" href="/#" title="GitHub"></a></li>
                            
                                <li id="RSS"><a class="RSS" target="_blank" href="/atom.xml" title="RSS"></a></li>
                            
                        </ul>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap">
  
    <article id="post-如何自适应宽度的水平居中" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2013-03-11-如何自适应宽度的水平居中.html" class="article-date">
      <time datetime="2013-03-11T01:38:52.000Z" itemprop="datePublished">2013-03-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2013-03-11-如何自适应宽度的水平居中.html">如何自适应宽度的水平居中</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>当父元素和子元素都没有定义宽度的情况下实现水平居中：</p>
<h2 id="display-inline-block"><a href="#display-inline-block" class="headerlink" title="display:inline-block"></a><code>display:inline-block</code></h2><p>可以使用text-align:center和display:inline-block相结合，这个技巧需要一个父元素。</p>
<pre style="margin: 15px 0; font: 100 12px/18px monaco, andale mono, courier new; padding: 10px 12px; border: #ccc 1px solid; border-left-width: 4px; background-color: #fefefe; box-shadow: 0 0 4px #eee; word-break: break-all; word-wrap: break-word; color: #444;"><span style="color: #170;">&lt;div</span> <span style="color: #00c;">class</span>=<span style="color: #a11;">"navbar"</span><span style="color: #170;">&gt;</span>
    <span style="color: #170;">&lt;ul</span><span style="color: #170;">&gt;</span>
        <span style="color: #170;">&lt;li</span><span style="color: #170;">&gt;</span><span style="color: #170;">&lt;a</span> <span style="color: #00c;">href</span>=<span style="color: #a11;">"/"</span><span style="color: #170;">&gt;</span>Home<span style="color: #170;">&lt;/a</span><span style="color: #170;">&gt;</span><span style="color: #170;">&lt;/li</span><span style="color: #170;">&gt;</span>
        …
    <span style="color: #170;">&lt;/ul</span><span style="color: #170;">&gt;</span>
<span style="color: #170;">&lt;/div</span><span style="color: #170;">&gt;</span></pre>
<pre style="margin: 15px 0; font: 100 12px/18px monaco, andale mono, courier new; padding: 10px 12px; border: #ccc 1px solid; border-left-width: 4px; background-color: #fefefe; box-shadow: 0 0 4px #eee; word-break: break-all; word-wrap: break-word; color: #444;">.<span style="color: #170;">navbar</span> {
    <span style="color: #000;">text-align</span>:<span style="color: #164;">center</span>;
}
.<span style="color: #170;">navbar</span> <span style="color: #170;">ul</span> {
    <span style="color: #000;">display</span>:<span style="color: #164;">inline-block</span>;
}
.<span style="color: #170;">navbar</span> <span style="color: #170;">li</span> {
    <span style="color: #000;">float</span>:<span style="color: #164;">left</span>;
}
.<span style="color: #170;">navbar</span> <span style="color: #170;">li</span> + <span style="color: #170;">li</span> {
    <span style="color: #000;">margin-left</span>:<span style="color: #164;">20px</span>;
}</pre>
IE系列IE8+支持，要IE7 IE6 支持需要加入以下代码使display:inline像display:inline-block一样
<pre style="margin: 15px 0; font: 100 12px/18px monaco, andale mono, courier new; padding: 10px 12px; border: #ccc 1px solid; border-left-width: 4px; background-color: #fefefe; box-shadow: 0 0 4px #eee; word-break: break-all; word-wrap: break-word; color: #444;">.<span style="color: #170;">navbar</span> <span style="color: #170;">ul</span> {
    *<span style="color: #000;">display</span>:<span style="color: #164;">inline</span>;
    *<span style="color: #000;">zoom</span>:<span style="color: #164;">1</span>;
}</pre>

<h2 id="position-relative"><a href="#position-relative" class="headerlink" title="position:relative"></a><code>position:relative</code></h2><p>使用position:relative与float相结合的技巧及其浮动和定位参照物的关系，这个技巧需要两个父元素，一个用来定位而另外一个用来避免出现滚动条。</p>
<pre style="margin: 15px 0; font: 100 12px/18px monaco, andale mono, courier new; padding: 10px 12px; border: #ccc 1px solid; border-left-width: 4px; background-color: #fefefe; box-shadow: 0 0 4px #eee; word-break: break-all; word-wrap: break-word; color: #444;"><span style="color: #170;">&lt;div</span> <span style="color: #00c;">class</span>=<span style="color: #a11;">"navbar"</span><span style="color: #170;">&gt;</span>
    <span style="color: #170;">&lt;div</span><span style="color: #170;">&gt;</span>
        <span style="color: #170;">&lt;ul</span><span style="color: #170;">&gt;</span>
            <span style="color: #170;">&lt;li</span><span style="color: #170;">&gt;</span><span style="color: #170;">&lt;a</span> <span style="color: #00c;">href</span>=<span style="color: #a11;">"/"</span><span style="color: #170;">&gt;</span>Home<span style="color: #170;">&lt;/a</span><span style="color: #170;">&gt;</span><span style="color: #170;">&lt;/li</span><span style="color: #170;">&gt;</span>
            …
        <span style="color: #170;">&lt;/ul</span><span style="color: #170;">&gt;</span>
    <span style="color: #170;">&lt;/div</span><span style="color: #170;">&gt;</span>
<span style="color: #170;">&lt;/div</span><span style="color: #170;">&gt;</span></pre>
<pre style="margin: 15px 0; font: 100 12px/18px monaco, andale mono, courier new; padding: 10px 12px; border: #ccc 1px solid; border-left-width: 4px; background-color: #fefefe; box-shadow: 0 0 4px #eee; word-break: break-all; word-wrap: break-word; color: #444;">.navbar {
    overflow:hidden;
}
.navbar &gt; div {
    position:relative;
    left:50%;
    float:left;
}
.navbar ul {
    position:relative;
    left:-50%;
    float:left;
}
.navbar li {
    float:left;
}
.navbar li + li {
    margin-left:20px;
}</pre>
IE7下需要加入下列代码支持：
<pre style="margin: 15px 0; font: 100 12px/18px monaco, andale mono, courier new; padding: 10px 12px; border: #ccc 1px solid; border-left-width: 4px; background-color: #fefefe; box-shadow: 0 0 4px #eee; word-break: break-all; word-wrap: break-word; color: #444;">.<span style="color: #170;">navbar</span> {
    <span style="color: #000;">position</span>:<span style="color: #164;">relative</span>;
}</pre>
&nbsp;

## `display:table`

如果向使用极少的标签实现，这个方法是个不错的选择。
<pre style="margin: 15px 0; font: 100 12px/18px monaco, andale mono, courier new; padding: 10px 12px; border: #ccc 1px solid; border-left-width: 4px; background-color: #fefefe; box-shadow: 0 0 4px #eee; word-break: break-all; word-wrap: break-word; color: #444;"><span style="color: #170;">&lt;ul</span> <span style="color: #00c;">class</span>=<span style="color: #a11;">"navbar"</span><span style="color: #170;">&gt;</span>
    <span style="color: #170;">&lt;li</span><span style="color: #170;">&gt;</span><span style="color: #170;">&lt;a</span> <span style="color: #00c;">href</span>=<span style="color: #a11;">"/"</span><span style="color: #170;">&gt;</span>Home<span style="color: #170;">&lt;/a</span><span style="color: #170;">&gt;</span><span style="color: #170;">&lt;/li</span><span style="color: #170;">&gt;</span>
    …
<span style="color: #170;">&lt;/ul</span><span style="color: #170;">&gt;</span></pre>
<pre style="margin: 15px 0; font: 100 12px/18px monaco, andale mono, courier new; padding: 10px 12px; border: #ccc 1px solid; border-left-width: 4px; background-color: #fefefe; box-shadow: 0 0 4px #eee; word-break: break-all; word-wrap: break-word; color: #444;">.<span style="color: #170;">navbar</span> {
    <span style="color: #000;">display</span>:<span style="color: #164;">table</span>;
    <span style="color: #000;">margin</span>:<span style="color: #164;">0</span> <span style="color: #164;">auto</span>;
}
.<span style="color: #170;">navbar</span> <span style="color: #170;">li</span> {
    <span style="color: #000;">display</span>:<span style="color: #164;">table-cell</span>;
}
.<span style="color: #170;">navbar</span> <span style="color: #170;">li</span> + <span style="color: #170;">li</span> {
    <span style="color: #000;">padding-left</span>:<span style="color: #164;">20px</span>;
}</pre>
不支持IE7及一下浏览器，其他的主流浏览器都支持。

## `display:inline-flex`

这个方法需要使用 flex-layout 的知识。
<pre style="margin: 15px 0; font: 100 12px/18px monaco, andale mono, courier new; padding: 10px 12px; border: #ccc 1px solid; border-left-width: 4px; background-color: #fefefe; box-shadow: 0 0 4px #eee; word-break: break-all; word-wrap: break-word; color: #444;"><span style="color: #170;">&lt;div</span> <span style="color: #00c;">class</span>=<span style="color: #a11;">"navbar"</span><span style="color: #170;">&gt;</span>
    <span style="color: #170;">&lt;ul</span><span style="color: #170;">&gt;</span>
        <span style="color: #170;">&lt;li</span><span style="color: #170;">&gt;</span><span style="color: #170;">&lt;a</span> <span style="color: #00c;">href</span>=<span style="color: #a11;">"/"</span><span style="color: #170;">&gt;</span>Home<span style="color: #170;">&lt;/a</span><span style="color: #170;">&gt;</span><span style="color: #170;">&lt;/li</span><span style="color: #170;">&gt;</span>
        …
    <span style="color: #170;">&lt;/ul</span><span style="color: #170;">&gt;</span>
<span style="color: #170;">&lt;/div</span><span style="color: #170;">&gt;</span></pre>
<pre style="margin: 15px 0; font: 100 12px/18px monaco, andale mono, courier new; padding: 10px 12px; border: #ccc 1px solid; border-left-width: 4px; background-color: #fefefe; box-shadow: 0 0 4px #eee; word-break: break-all; word-wrap: break-word; color: #444;">.navbar {
    text-align:center;
}
.navbar &gt; ul {
    display:-webkit-inline-box;
    display:-moz-inline-box;
    display:-ms-inline-flexbox;
    display:-webkit-inline-flex;
    display:inline-flex;
}
.navbar li + li {
    margin-left:20px;
}</pre>

<h3 id="使用CSS-fit-content-值"><a href="#使用CSS-fit-content-值" class="headerlink" title="使用CSS fit-content 值"></a>使用CSS fit-content 值</h3><p>下面看看如何用fit-content创建一个包含子元素浮动的未知宽度的导航。</p>
<p><pre style="margin: 15px 0; font: 100 12px/18px monaco, andale mono, courier new; padding: 10px 12px; border: #ccc 1px solid; border-left-width: 4px; background-color: #fefefe; box-shadow: 0 0 4px #eee; word-break: break-all; word-wrap: break-word; color: #444;"><span style="color: #170;">&lt;div</span> <span style="color: #00c;">class</span>=<span style="color: #a11;">“navbar center”</span><span style="color: #170;">&gt;</span><br>    <span style="color: #170;">&lt;ul</span><span style="color: #170;">&gt;</span><br>        <span style="color: #170;">&lt;li</span><span style="color: #170;">&gt;</span><span style="color: #170;">&lt;a</span> <span style="color: #00c;">href</span>=<span style="color: #a11;">“/“</span><span style="color: #170;">&gt;</span>Home<span style="color: #170;">&lt;/a</span><span style="color: #170;">&gt;</span><span style="color: #170;">&lt;/li</span><span style="color: #170;">&gt;</span><br>        <span style="color: #170;">&lt;li</span><span style="color: #170;">&gt;</span><span style="color: #170;">&lt;a</span> <span style="color: #00c;">href</span>=<span style="color: #a11;">“/“</span><span style="color: #170;">&gt;</span>About us<span style="color: #170;">&lt;/a</span><span style="color: #170;">&gt;</span><span style="color: #170;">&lt;/li</span><span style="color: #170;">&gt;</span><br>        <span style="color: #170;">&lt;li</span><span style="color: #170;">&gt;</span><span style="color: #170;">&lt;a</span> <span style="color: #00c;">href</span>=<span style="color: #a11;">“/“</span><span style="color: #170;">&gt;</span>Our products<span style="color: #170;">&lt;/a</span><span style="color: #170;">&gt;</span><span style="color: #170;">&lt;/li</span><span style="color: #170;">&gt;</span><br>        <span style="color: #170;">&lt;li</span><span style="color: #170;">&gt;</span><span style="color: #170;">&lt;a</span> <span style="color: #00c;">href</span>=<span style="color: #a11;">“/“</span><span style="color: #170;">&gt;</span>Customer support<span style="color: #170;">&lt;/a</span><span style="color: #170;">&gt;</span><span style="color: #170;">&lt;/li</span><span style="color: #170;">&gt;</span><br>        <span style="color: #170;">&lt;li</span><span style="color: #170;">&gt;</span><span style="color: #170;">&lt;a</span> <span style="color: #00c;">href</span>=<span style="color: #a11;">“/“</span><span style="color: #170;">&gt;</span>Contact<span style="color: #170;">&lt;/a</span><span style="color: #170;">&gt;</span><span style="color: #170;">&lt;/li</span><span style="color: #170;">&gt;</span><br>    <span style="color: #170;">&lt;/ul</span><span style="color: #170;">&gt;</span><br><span style="color: #170;">&lt;/div</span><span style="color: #170;">&gt;</span></pre></p>
<p><pre style="margin: 15px 0; font: 100 12px/18px monaco, andale mono, courier new; padding: 10px 12px; border: #ccc 1px solid; border-left-width: 4px; background-color: #fefefe; box-shadow: 0 0 4px #eee; word-break: break-all; word-wrap: break-word; color: #444;">.<span style="color: #170;">center</span> <span style="color: #170;">ul</span>{<br>    <span style="color: #000;">width</span>: <span style="color: #164;">-moz-fit-content</span>;<br>    <span style="color: #000;">width</span>: <span style="color: #164;">-webkit-fit-content</span>;<br>    <span style="color: #000;">width</span>: <span style="color: #164;">fit-content</span>;<br>    <span style="color: #000;">margin</span>: <span style="color: #164;">auto</span>;<br>}</pre><br>浏览器支持度较低 只Chrome和Firefox这样的-webkit- -moz-内核浏览器。当然以后慢慢会发展起来的。<br>这个方式是推动浏览器发展的一个新的东西，目前供应于所以可以写前缀的浏览器，并没有工作在IE9和IE9以下。</p>
<p>根据你的需求来选择合适的方法吧，display:inline-block兼容性较好，flex-box将会用于未来。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-如何自适应宽度的水平居中 - 副本" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2013-03-11-如何自适应宽度的水平居中 - 副本.html" class="article-date">
      <time datetime="2013-03-11T01:38:52.000Z" itemprop="datePublished">2013-03-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2013-03-11-如何自适应宽度的水平居中 - 副本.html">如何自适应宽度的水平居中</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>当父元素和子元素都没有定义宽度的情况下实现水平居中：</p>
<h2 id="display-inline-block"><a href="#display-inline-block" class="headerlink" title="display:inline-block"></a><code>display:inline-block</code></h2><p>可以使用text-align:center和display:inline-block相结合，这个技巧需要一个父元素。</p>
<pre style="margin: 15px 0; font: 100 12px/18px monaco, andale mono, courier new; padding: 10px 12px; border: #ccc 1px solid; border-left-width: 4px; background-color: #fefefe; box-shadow: 0 0 4px #eee; word-break: break-all; word-wrap: break-word; color: #444;"><span style="color: #170;">&lt;div</span> <span style="color: #00c;">class</span>=<span style="color: #a11;">"navbar"</span><span style="color: #170;">&gt;</span>
    <span style="color: #170;">&lt;ul</span><span style="color: #170;">&gt;</span>
        <span style="color: #170;">&lt;li</span><span style="color: #170;">&gt;</span><span style="color: #170;">&lt;a</span> <span style="color: #00c;">href</span>=<span style="color: #a11;">"/"</span><span style="color: #170;">&gt;</span>Home<span style="color: #170;">&lt;/a</span><span style="color: #170;">&gt;</span><span style="color: #170;">&lt;/li</span><span style="color: #170;">&gt;</span>
        …
    <span style="color: #170;">&lt;/ul</span><span style="color: #170;">&gt;</span>
<span style="color: #170;">&lt;/div</span><span style="color: #170;">&gt;</span></pre>
<pre style="margin: 15px 0; font: 100 12px/18px monaco, andale mono, courier new; padding: 10px 12px; border: #ccc 1px solid; border-left-width: 4px; background-color: #fefefe; box-shadow: 0 0 4px #eee; word-break: break-all; word-wrap: break-word; color: #444;">.<span style="color: #170;">navbar</span> {
    <span style="color: #000;">text-align</span>:<span style="color: #164;">center</span>;
}
.<span style="color: #170;">navbar</span> <span style="color: #170;">ul</span> {
    <span style="color: #000;">display</span>:<span style="color: #164;">inline-block</span>;
}
.<span style="color: #170;">navbar</span> <span style="color: #170;">li</span> {
    <span style="color: #000;">float</span>:<span style="color: #164;">left</span>;
}
.<span style="color: #170;">navbar</span> <span style="color: #170;">li</span> + <span style="color: #170;">li</span> {
    <span style="color: #000;">margin-left</span>:<span style="color: #164;">20px</span>;
}</pre>
IE系列IE8+支持，要IE7 IE6 支持需要加入以下代码使display:inline像display:inline-block一样
<pre style="margin: 15px 0; font: 100 12px/18px monaco, andale mono, courier new; padding: 10px 12px; border: #ccc 1px solid; border-left-width: 4px; background-color: #fefefe; box-shadow: 0 0 4px #eee; word-break: break-all; word-wrap: break-word; color: #444;">.<span style="color: #170;">navbar</span> <span style="color: #170;">ul</span> {
    *<span style="color: #000;">display</span>:<span style="color: #164;">inline</span>;
    *<span style="color: #000;">zoom</span>:<span style="color: #164;">1</span>;
}</pre>

<h2 id="position-relative"><a href="#position-relative" class="headerlink" title="position:relative"></a><code>position:relative</code></h2><p>使用position:relative与float相结合的技巧及其浮动和定位参照物的关系，这个技巧需要两个父元素，一个用来定位而另外一个用来避免出现滚动条。</p>
<pre style="margin: 15px 0; font: 100 12px/18px monaco, andale mono, courier new; padding: 10px 12px; border: #ccc 1px solid; border-left-width: 4px; background-color: #fefefe; box-shadow: 0 0 4px #eee; word-break: break-all; word-wrap: break-word; color: #444;"><span style="color: #170;">&lt;div</span> <span style="color: #00c;">class</span>=<span style="color: #a11;">"navbar"</span><span style="color: #170;">&gt;</span>
    <span style="color: #170;">&lt;div</span><span style="color: #170;">&gt;</span>
        <span style="color: #170;">&lt;ul</span><span style="color: #170;">&gt;</span>
            <span style="color: #170;">&lt;li</span><span style="color: #170;">&gt;</span><span style="color: #170;">&lt;a</span> <span style="color: #00c;">href</span>=<span style="color: #a11;">"/"</span><span style="color: #170;">&gt;</span>Home<span style="color: #170;">&lt;/a</span><span style="color: #170;">&gt;</span><span style="color: #170;">&lt;/li</span><span style="color: #170;">&gt;</span>
            …
        <span style="color: #170;">&lt;/ul</span><span style="color: #170;">&gt;</span>
    <span style="color: #170;">&lt;/div</span><span style="color: #170;">&gt;</span>
<span style="color: #170;">&lt;/div</span><span style="color: #170;">&gt;</span></pre>
<pre style="margin: 15px 0; font: 100 12px/18px monaco, andale mono, courier new; padding: 10px 12px; border: #ccc 1px solid; border-left-width: 4px; background-color: #fefefe; box-shadow: 0 0 4px #eee; word-break: break-all; word-wrap: break-word; color: #444;">.navbar {
    overflow:hidden;
}
.navbar &gt; div {
    position:relative;
    left:50%;
    float:left;
}
.navbar ul {
    position:relative;
    left:-50%;
    float:left;
}
.navbar li {
    float:left;
}
.navbar li + li {
    margin-left:20px;
}</pre>
IE7下需要加入下列代码支持：
<pre style="margin: 15px 0; font: 100 12px/18px monaco, andale mono, courier new; padding: 10px 12px; border: #ccc 1px solid; border-left-width: 4px; background-color: #fefefe; box-shadow: 0 0 4px #eee; word-break: break-all; word-wrap: break-word; color: #444;">.<span style="color: #170;">navbar</span> {
    <span style="color: #000;">position</span>:<span style="color: #164;">relative</span>;
}</pre>
&nbsp;

## `display:table`

如果向使用极少的标签实现，这个方法是个不错的选择。
<pre style="margin: 15px 0; font: 100 12px/18px monaco, andale mono, courier new; padding: 10px 12px; border: #ccc 1px solid; border-left-width: 4px; background-color: #fefefe; box-shadow: 0 0 4px #eee; word-break: break-all; word-wrap: break-word; color: #444;"><span style="color: #170;">&lt;ul</span> <span style="color: #00c;">class</span>=<span style="color: #a11;">"navbar"</span><span style="color: #170;">&gt;</span>
    <span style="color: #170;">&lt;li</span><span style="color: #170;">&gt;</span><span style="color: #170;">&lt;a</span> <span style="color: #00c;">href</span>=<span style="color: #a11;">"/"</span><span style="color: #170;">&gt;</span>Home<span style="color: #170;">&lt;/a</span><span style="color: #170;">&gt;</span><span style="color: #170;">&lt;/li</span><span style="color: #170;">&gt;</span>
    …
<span style="color: #170;">&lt;/ul</span><span style="color: #170;">&gt;</span></pre>
<pre style="margin: 15px 0; font: 100 12px/18px monaco, andale mono, courier new; padding: 10px 12px; border: #ccc 1px solid; border-left-width: 4px; background-color: #fefefe; box-shadow: 0 0 4px #eee; word-break: break-all; word-wrap: break-word; color: #444;">.<span style="color: #170;">navbar</span> {
    <span style="color: #000;">display</span>:<span style="color: #164;">table</span>;
    <span style="color: #000;">margin</span>:<span style="color: #164;">0</span> <span style="color: #164;">auto</span>;
}
.<span style="color: #170;">navbar</span> <span style="color: #170;">li</span> {
    <span style="color: #000;">display</span>:<span style="color: #164;">table-cell</span>;
}
.<span style="color: #170;">navbar</span> <span style="color: #170;">li</span> + <span style="color: #170;">li</span> {
    <span style="color: #000;">padding-left</span>:<span style="color: #164;">20px</span>;
}</pre>
不支持IE7及一下浏览器，其他的主流浏览器都支持。

## `display:inline-flex`

这个方法需要使用 flex-layout 的知识。
<pre style="margin: 15px 0; font: 100 12px/18px monaco, andale mono, courier new; padding: 10px 12px; border: #ccc 1px solid; border-left-width: 4px; background-color: #fefefe; box-shadow: 0 0 4px #eee; word-break: break-all; word-wrap: break-word; color: #444;"><span style="color: #170;">&lt;div</span> <span style="color: #00c;">class</span>=<span style="color: #a11;">"navbar"</span><span style="color: #170;">&gt;</span>
    <span style="color: #170;">&lt;ul</span><span style="color: #170;">&gt;</span>
        <span style="color: #170;">&lt;li</span><span style="color: #170;">&gt;</span><span style="color: #170;">&lt;a</span> <span style="color: #00c;">href</span>=<span style="color: #a11;">"/"</span><span style="color: #170;">&gt;</span>Home<span style="color: #170;">&lt;/a</span><span style="color: #170;">&gt;</span><span style="color: #170;">&lt;/li</span><span style="color: #170;">&gt;</span>
        …
    <span style="color: #170;">&lt;/ul</span><span style="color: #170;">&gt;</span>
<span style="color: #170;">&lt;/div</span><span style="color: #170;">&gt;</span></pre>
<pre style="margin: 15px 0; font: 100 12px/18px monaco, andale mono, courier new; padding: 10px 12px; border: #ccc 1px solid; border-left-width: 4px; background-color: #fefefe; box-shadow: 0 0 4px #eee; word-break: break-all; word-wrap: break-word; color: #444;">.navbar {
    text-align:center;
}
.navbar &gt; ul {
    display:-webkit-inline-box;
    display:-moz-inline-box;
    display:-ms-inline-flexbox;
    display:-webkit-inline-flex;
    display:inline-flex;
}
.navbar li + li {
    margin-left:20px;
}</pre>

<h3 id="使用CSS-fit-content-值"><a href="#使用CSS-fit-content-值" class="headerlink" title="使用CSS fit-content 值"></a>使用CSS fit-content 值</h3><p>下面看看如何用fit-content创建一个包含子元素浮动的未知宽度的导航。</p>
<p><pre style="margin: 15px 0; font: 100 12px/18px monaco, andale mono, courier new; padding: 10px 12px; border: #ccc 1px solid; border-left-width: 4px; background-color: #fefefe; box-shadow: 0 0 4px #eee; word-break: break-all; word-wrap: break-word; color: #444;"><span style="color: #170;">&lt;div</span> <span style="color: #00c;">class</span>=<span style="color: #a11;">“navbar center”</span><span style="color: #170;">&gt;</span><br>    <span style="color: #170;">&lt;ul</span><span style="color: #170;">&gt;</span><br>        <span style="color: #170;">&lt;li</span><span style="color: #170;">&gt;</span><span style="color: #170;">&lt;a</span> <span style="color: #00c;">href</span>=<span style="color: #a11;">“/“</span><span style="color: #170;">&gt;</span>Home<span style="color: #170;">&lt;/a</span><span style="color: #170;">&gt;</span><span style="color: #170;">&lt;/li</span><span style="color: #170;">&gt;</span><br>        <span style="color: #170;">&lt;li</span><span style="color: #170;">&gt;</span><span style="color: #170;">&lt;a</span> <span style="color: #00c;">href</span>=<span style="color: #a11;">“/“</span><span style="color: #170;">&gt;</span>About us<span style="color: #170;">&lt;/a</span><span style="color: #170;">&gt;</span><span style="color: #170;">&lt;/li</span><span style="color: #170;">&gt;</span><br>        <span style="color: #170;">&lt;li</span><span style="color: #170;">&gt;</span><span style="color: #170;">&lt;a</span> <span style="color: #00c;">href</span>=<span style="color: #a11;">“/“</span><span style="color: #170;">&gt;</span>Our products<span style="color: #170;">&lt;/a</span><span style="color: #170;">&gt;</span><span style="color: #170;">&lt;/li</span><span style="color: #170;">&gt;</span><br>        <span style="color: #170;">&lt;li</span><span style="color: #170;">&gt;</span><span style="color: #170;">&lt;a</span> <span style="color: #00c;">href</span>=<span style="color: #a11;">“/“</span><span style="color: #170;">&gt;</span>Customer support<span style="color: #170;">&lt;/a</span><span style="color: #170;">&gt;</span><span style="color: #170;">&lt;/li</span><span style="color: #170;">&gt;</span><br>        <span style="color: #170;">&lt;li</span><span style="color: #170;">&gt;</span><span style="color: #170;">&lt;a</span> <span style="color: #00c;">href</span>=<span style="color: #a11;">“/“</span><span style="color: #170;">&gt;</span>Contact<span style="color: #170;">&lt;/a</span><span style="color: #170;">&gt;</span><span style="color: #170;">&lt;/li</span><span style="color: #170;">&gt;</span><br>    <span style="color: #170;">&lt;/ul</span><span style="color: #170;">&gt;</span><br><span style="color: #170;">&lt;/div</span><span style="color: #170;">&gt;</span></pre></p>
<p><pre style="margin: 15px 0; font: 100 12px/18px monaco, andale mono, courier new; padding: 10px 12px; border: #ccc 1px solid; border-left-width: 4px; background-color: #fefefe; box-shadow: 0 0 4px #eee; word-break: break-all; word-wrap: break-word; color: #444;">.<span style="color: #170;">center</span> <span style="color: #170;">ul</span>{<br>    <span style="color: #000;">width</span>: <span style="color: #164;">-moz-fit-content</span>;<br>    <span style="color: #000;">width</span>: <span style="color: #164;">-webkit-fit-content</span>;<br>    <span style="color: #000;">width</span>: <span style="color: #164;">fit-content</span>;<br>    <span style="color: #000;">margin</span>: <span style="color: #164;">auto</span>;<br>}</pre><br>浏览器支持度较低 只Chrome和Firefox这样的-webkit- -moz-内核浏览器。当然以后慢慢会发展起来的。<br>这个方式是推动浏览器发展的一个新的东西，目前供应于所以可以写前缀的浏览器，并没有工作在IE9和IE9以下。</p>
<p>根据你的需求来选择合适的方法吧，display:inline-block兼容性较好，flex-box将会用于未来。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-IE hasLayout的问题总结 - 副本" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2013-03-07-IE hasLayout的问题总结 - 副本.html" class="article-date">
      <time datetime="2013-03-07T10:12:07.000Z" itemprop="datePublished">2013-03-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2013-03-07-IE hasLayout的问题总结 - 副本.html">IE hasLayout的问题总结</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><strong>介绍 </strong></p>
<p>这篇文章是一个总结haslayout的文章。</p>
<p><strong>更新：haslayout在ie8的标准模式下已经被废弃了，但是在ie7的兼容版本以及以下的版本是仍然存在的。</strong></p>
<p><strong>什么是haslayout？ </strong></p>
<p>MSIE  有一个很早很早，过时的渲染引擎 <a href="http://en.wikipedia.org/wiki/Mosaic_web_browser" title="Mosaic Web Browser Wiki" target="_blank" rel="external">Mosai</a>c . 在表格布局的时代。几乎是所有的元素（除了内联内容）都是一个盒子。内容几乎不可能超过表格的</p>
<p>单元格。表格的单元格不可能超出表格。</p>
<p>很多年过去了。微软开始采用<a href="http://en.wikipedia.org/wiki/Trident_(layout_engine" target="_blank" rel="external">Trident</a> “Trident Engine Wiki”) engine 来使用CSS，但是，CSS改变了最初的这个古老引擎的假设（最重要的一点就是任何元素都会包含它的内容）。</p>
<p>但是CSS允许内容超出元素(就是内容浮动的时候，或者内容太高、宽去适应包含盒子)</p>
<p><strong>haslayout是怎么来的？</strong></p>
<p>为了解决这个问题，微软的天才coder决定去修理他们的这个古老的引擎，因此haslayout这个属性就诞生了。每个元素都有haslayout这个属性去设置true</p>
<p>或者false，如果它设置成了true，它就不得不去渲染它自己，因此元素不得不扩展去包含它的流出的内容。例如浮动或者很长很长的没有截断的单词，如果</p>
<p>haslayout没有被设置成true，那么元素得依靠某个祖先元素来渲染它。这就是很多的ie bugs诞生的地方。</p>
<p>haslayout不是一个CSS属性，你不能这样的来设置它 haslayout:true;一个元素被设置成haslayout：true将被渲染成一个 having haslayout，反之。</p>
<p><strong>那些元素本身就有haslayout属性</strong></p>
<div>

<ul>
<li><a href="http://www.w3.org/TR/html401/struct/global.html#edef-HTML" title="HTML 4.01 Specification: `html` element" target="_blank" rel="external"><code>&amp;lt;html&amp;gt;</code></a>, <a href="http://www.w3.org/TR/html401/struct/global.html#edef-BODY" title="HTML 4.01 Specification: `body` element" target="_blank" rel="external"><code>&amp;lt;body&amp;gt;</code></a></li>
<li><a href="http://www.w3.org/TR/html401/struct/tables.html#edef-TABLE" title="HTML 4.01 Specification: `table` element" target="_blank" rel="external"><code>&amp;lt;table&amp;gt;</code></a>, <a href="http://www.w3.org/TR/html401/struct/tables.html#edef-TR" title="HTML 4.01 Specification: `tr` element" target="_blank" rel="external"><code>&amp;lt;tr&amp;gt;</code></a>, <a href="http://www.w3.org/TR/html401/struct/tables.html#edef-TH" title="HTML 4.01 Specification: `th` element" target="_blank" rel="external"><code>&amp;lt;th&amp;gt;</code></a>, <a href="http://www.w3.org/TR/html401/struct/tables.html#edef-TD" title="HTML 4.01 Specification: `td` element" target="_blank" rel="external"><code>&amp;lt;td&amp;gt;</code></a></li>
<li><a href="http://www.w3.org/TR/html401/present/frames.html#edef-IFRAME" title="HTML 4.01: Specification: `iframe` element" target="_blank" rel="external"><code>&amp;lt;iframe&amp;gt;</code></a>, <a href="http://alistapart.com/articles/byebyeembed" title="Evading non-standard `embed` element" target="_blank" rel="external"><code>&amp;lt;embed&amp;gt;</code></a> (non-standard element), <a href="http://www.w3.org/TR/html401/struct/objects.html#edef-OBJECT" title="HTML 4.01 Specification: `object` element" target="_blank" rel="external"><code>&amp;lt;object&amp;gt;</code></a>, <a href="http://www.w3.org/TR/html401/struct/objects.html#edef-APPLET" title="HTML 4.01 Specification: `applet` element" target="_blank" rel="external"><code>&amp;lt;applet&amp;gt;</code></a></li>
<li><a href="http://www.w3.org/TR/html401/struct/objects.html#edef-IMG" title="HTML 4.01 Specification: `img` element" target="_blank" rel="external"><code>&amp;lt;img&amp;gt;</code></a></li>
<li><a href="http://www.w3.org/TR/html401/present/graphics.html#edef-HR" title="HTML 4.01 Specification: `hr` element" target="_blank" rel="external"><code>&amp;lt;hr&amp;gt;</code></a></li>
<li><a href="http://www.w3.org/TR/html401/interact/forms.html#edef-INPUT" title="HTML 4.01 Specification: `input` element" target="_blank" rel="external"><code>&amp;lt;input&amp;gt;</code></a>, <a href="http://www.w3.org/TR/html401/interact/forms.html#edef-BUTTON" title="HTML 4.01 Specification: `button` element" target="_blank" rel="external"><code>&amp;lt;button&amp;gt;</code></a>, <a href="http://www.w3.org/TR/html401/interact/forms.html#edef-SELECT" title="HTML 4.01 Specification: `select` element" target="_blank" rel="external"><code>&amp;lt;select&amp;gt;</code></a>, <a href="http://www.w3.org/TR/html401/interact/forms.html#edef-TEXTAREA" title="HTML 4.01 Specification: `textarea` element" target="_blank" rel="external"><code>&amp;lt;textarea&amp;gt;</code></a>, <a href="http://www.w3.org/TR/html401/interact/forms.html#edef-FIELDSET" title="HTML 4.01 Specification: `fieldset` element" target="_blank" rel="external"><code>&amp;lt;fieldset&amp;gt;</code></a>, <a href="http://www.w3.org/TR/html401/interact/forms.html#edef-LEGEND" title="HTML 4.01 Specification: `legend` element" target="_blank" rel="external"><code>&amp;lt;legend&amp;gt;</code></a></li>
<li><code>&amp;lt;marquee&amp;gt;</code> (don’t ever use this one, non-standard and annoying)<br></li></ul></div><br>这个列表时不完善的。很多元素在微软的官方网站上没有提到，但是有一个方法很容易的测试到一个元素是否有layout，例如下代码：

<p>&lt;div id=”menu”&gt; … &lt;/div&gt;</p>
<p>为了判断这个div的haslayout属性值，我们可以在浏览器地址栏中输入如下代码：</p>
<p>javascript:alert(<strong>menu</strong>.currentStyle.hasLayout)</p>
<p>运行了这个代码之后就会反映出这个div的haslayout的属性值</p>
<p><strong>如何设置haslayout </strong></p>
<p>设置haslayout，换句话来说，就是给定一个布局，相对来说比haslayout等于false要简单。</p>
<p>以下属性和值将给定一个元素布局</p>
<div>

<ul>
<li><code>[position](http://w3.org/TR/CSS21/visuren.html#propdef-position &quot;CSS Specification:</code>position<code>property&quot;): absolute</code></li>
<li><code>[float](http://w3.org/TR/CSS21/visuren.html#propdef-float &quot;CSS Specification:</code>float<code>property&quot;): left</code> or <code>right</code></li>
<li><code>[display](http://w3.org/TR/CSS21/visuren.html#propdef-display &quot;CSS Specification:</code>display<code>property&quot;): inline-block</code></li>
<li><a href="http://w3.org/TR/CSS21/visudet.html#propdef-width" title="CSS Specification: `width` property" target="_blank" rel="external"><code>width</code></a>: <em>any</em> value <em>other</em> than <code>auto</code></li>
<li><a href="http://w3.org/TR/CSS21/visudet.html#propdef-height" title="CSS Specification: `height` property" target="_blank" rel="external"><code>height</code></a>: <em>any</em> value <em>other</em> than <code>auto</code></li>
<li><code>zoom</code>: <em>any</em> value <em>other</em> than <code>normal</code> (see <a href="http://haslayout.net/haslayout#zoomExplained" title="Skip to description of `zoom` property" target="_blank" rel="external">description</a> below)</li>
<li><code>writing-mode: tb-rl</code> (see <a href="http://haslayout.net/haslayout#zoomExplained" title="Skip to description of `writing-mode` property" target="_blank" rel="external">description</a> below)</li>
</ul>
<p>在ie7中, 也有一些属性 give “layout”:</p>
<ul>
<li><code>[overflow](http://w3.org/TR/CSS21/visufx.html#propdef-overflow &quot;CSS Specification:</code>overflow<code>property&quot;): hidden</code> or <code>scroll</code> or <code>auto</code></li>
<li><code>[overflow-x](http://www.w3.org/TR/css3-box/#overflow-x &quot;CSS3 Technical Report:</code>overflow-x<code>property&quot;): hidden</code> or <code>scroll</code> or <code>auto</code></li>
<li><code>[overflow-y](http://www.w3.org/TR/css3-box/#overflow-y &quot;CSS3 Technical Report:</code>oveflow-y<code>property&quot;): hidden</code> or <code>scroll</code> or <code>auto</code></li>
<li><a href="http://w3.org/TR/CSS21/visudet.html#propdef-min-width" title="CSS Specification: `min-width` property" target="_blank" rel="external"><code>min-width</code></a>: <em>any</em> value <em>other</em> than <code>auto</code></li>
<li><a href="http://w3.org/TR/CSS21/visudet.html#propdef-max-width" title="CSS Specification: `max-width` property" target="_blank" rel="external"><code>max-width</code></a>: <em>any</em> value <em>other</em> than <code>auto</code></li>
<li><a href="http://w3.org/TR/CSS21/visudet.html#propdef-min-height" title="CSS Specification: `min-height` property" target="_blank" rel="external"><code>min-height</code></a>: <em>any</em> value <em>other</em> than <code>auto</code></li>
<li><a href="http://w3.org/TR/CSS21/visudet.html#propdef-max-height" title="CSS Specification: `max-height` property" target="_blank" rel="external"><code>max-height</code></a>: <em>any</em> value <em>other</em> than <code>auto</code><br></li></ul></div><br>在ie8的标准模式中，微软已经废弃了haslayout属性了，但是在ie7的兼容模式中，仍然存在着这个属性。

<p>你可能对zoom 和write-mode这2个属性不太熟悉，他们都是微软的扩展属性。他们仅仅在ie中有效并且将来可能无效，因此我建议你把他们放入condcoms</p>
<p>write-mode属性在css3技术文档中已经出现了。zoom可能被提议，但是目前还没有。</p>
<p>zoom：1作者认为是最好的触发haslayout属性的组合，因为它对房前元素没有一点影响。</p>
<p>write-mode 就是字体排版布局的方式。</p>
<p>设置display：inline-block没有移除布局，这个技巧可以给元素设置成haslayout：true；</p>
<p>它相当于</p>
<p>div { display: inline-block; } div { display: block; }</p>
<p><span style="color: #29170d; font-family: 'Trebuchet MS', Arial, Helvetica, sans-serif;">设置</span>contenteditable也给一个元素设置成了haslayout：true。例如：&lt;p contenteditable=”true”&gt;so lame&lt;/p&gt;</p>
<p>你可能从来不用它来设置haslayout：true，写在这里只是为了一个信息的目的。不仅contenteditable是微软的一个属性，而且他还可以允许用户</p>
<p>编译元素的内容。这点有可能使用户困惑。</p>
<p>hasLayout 是一个可读的属性，不能通过js来修改它。</p>
<p><strong>我恨它 </strong></p>
<p>这听起来挺好的直到你碰到了一个bug并且把haslayout设置成true来解决。由于haslayout是可读的，所以不可能把它设置成一个false。幸运的</p>
<p>是，ie的很多bug都是由于元素没有设置成haslayout：true。</p>
<p><strong>bug </strong></p>
<p>在我的经验中，ie下的80% 的bug都是由于元素没有haslayout</p>
<p><abbr title="Internet Explorer">IE</abbr> hasLayout bugs经常出现各种很奇怪的问题，如果ie有些很难解释的问题，第一件事情要做的就是给该元素一个layout。</p>
<p>———END———-</p>
<p>&nbsp;</p>
<p><strong>本文原文地址：</strong><a href="http://www.cnblogs.com/yupeng/archive/2011/04/11/2012996.html" target="_blank" rel="external">http://www.cnblogs.com/yupeng/archive/2011/04/11/2012996.html</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-IE hasLayout的问题总结" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2013-03-07-IE hasLayout的问题总结.html" class="article-date">
      <time datetime="2013-03-07T10:12:07.000Z" itemprop="datePublished">2013-03-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2013-03-07-IE hasLayout的问题总结.html">IE hasLayout的问题总结</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><strong>介绍 </strong></p>
<p>这篇文章是一个总结haslayout的文章。</p>
<p><strong>更新：haslayout在ie8的标准模式下已经被废弃了，但是在ie7的兼容版本以及以下的版本是仍然存在的。</strong></p>
<p><strong>什么是haslayout？ </strong></p>
<p>MSIE  有一个很早很早，过时的渲染引擎 <a href="http://en.wikipedia.org/wiki/Mosaic_web_browser" title="Mosaic Web Browser Wiki" target="_blank" rel="external">Mosai</a>c . 在表格布局的时代。几乎是所有的元素（除了内联内容）都是一个盒子。内容几乎不可能超过表格的</p>
<p>单元格。表格的单元格不可能超出表格。</p>
<p>很多年过去了。微软开始采用<a href="http://en.wikipedia.org/wiki/Trident_(layout_engine" target="_blank" rel="external">Trident</a> “Trident Engine Wiki”) engine 来使用CSS，但是，CSS改变了最初的这个古老引擎的假设（最重要的一点就是任何元素都会包含它的内容）。</p>
<p>但是CSS允许内容超出元素(就是内容浮动的时候，或者内容太高、宽去适应包含盒子)</p>
<p><strong>haslayout是怎么来的？</strong></p>
<p>为了解决这个问题，微软的天才coder决定去修理他们的这个古老的引擎，因此haslayout这个属性就诞生了。每个元素都有haslayout这个属性去设置true</p>
<p>或者false，如果它设置成了true，它就不得不去渲染它自己，因此元素不得不扩展去包含它的流出的内容。例如浮动或者很长很长的没有截断的单词，如果</p>
<p>haslayout没有被设置成true，那么元素得依靠某个祖先元素来渲染它。这就是很多的ie bugs诞生的地方。</p>
<p>haslayout不是一个CSS属性，你不能这样的来设置它 haslayout:true;一个元素被设置成haslayout：true将被渲染成一个 having haslayout，反之。</p>
<p><strong>那些元素本身就有haslayout属性</strong></p>
<div>

<ul>
<li><a href="http://www.w3.org/TR/html401/struct/global.html#edef-HTML" title="HTML 4.01 Specification: `html` element" target="_blank" rel="external"><code>&amp;lt;html&amp;gt;</code></a>, <a href="http://www.w3.org/TR/html401/struct/global.html#edef-BODY" title="HTML 4.01 Specification: `body` element" target="_blank" rel="external"><code>&amp;lt;body&amp;gt;</code></a></li>
<li><a href="http://www.w3.org/TR/html401/struct/tables.html#edef-TABLE" title="HTML 4.01 Specification: `table` element" target="_blank" rel="external"><code>&amp;lt;table&amp;gt;</code></a>, <a href="http://www.w3.org/TR/html401/struct/tables.html#edef-TR" title="HTML 4.01 Specification: `tr` element" target="_blank" rel="external"><code>&amp;lt;tr&amp;gt;</code></a>, <a href="http://www.w3.org/TR/html401/struct/tables.html#edef-TH" title="HTML 4.01 Specification: `th` element" target="_blank" rel="external"><code>&amp;lt;th&amp;gt;</code></a>, <a href="http://www.w3.org/TR/html401/struct/tables.html#edef-TD" title="HTML 4.01 Specification: `td` element" target="_blank" rel="external"><code>&amp;lt;td&amp;gt;</code></a></li>
<li><a href="http://www.w3.org/TR/html401/present/frames.html#edef-IFRAME" title="HTML 4.01: Specification: `iframe` element" target="_blank" rel="external"><code>&amp;lt;iframe&amp;gt;</code></a>, <a href="http://alistapart.com/articles/byebyeembed" title="Evading non-standard `embed` element" target="_blank" rel="external"><code>&amp;lt;embed&amp;gt;</code></a> (non-standard element), <a href="http://www.w3.org/TR/html401/struct/objects.html#edef-OBJECT" title="HTML 4.01 Specification: `object` element" target="_blank" rel="external"><code>&amp;lt;object&amp;gt;</code></a>, <a href="http://www.w3.org/TR/html401/struct/objects.html#edef-APPLET" title="HTML 4.01 Specification: `applet` element" target="_blank" rel="external"><code>&amp;lt;applet&amp;gt;</code></a></li>
<li><a href="http://www.w3.org/TR/html401/struct/objects.html#edef-IMG" title="HTML 4.01 Specification: `img` element" target="_blank" rel="external"><code>&amp;lt;img&amp;gt;</code></a></li>
<li><a href="http://www.w3.org/TR/html401/present/graphics.html#edef-HR" title="HTML 4.01 Specification: `hr` element" target="_blank" rel="external"><code>&amp;lt;hr&amp;gt;</code></a></li>
<li><a href="http://www.w3.org/TR/html401/interact/forms.html#edef-INPUT" title="HTML 4.01 Specification: `input` element" target="_blank" rel="external"><code>&amp;lt;input&amp;gt;</code></a>, <a href="http://www.w3.org/TR/html401/interact/forms.html#edef-BUTTON" title="HTML 4.01 Specification: `button` element" target="_blank" rel="external"><code>&amp;lt;button&amp;gt;</code></a>, <a href="http://www.w3.org/TR/html401/interact/forms.html#edef-SELECT" title="HTML 4.01 Specification: `select` element" target="_blank" rel="external"><code>&amp;lt;select&amp;gt;</code></a>, <a href="http://www.w3.org/TR/html401/interact/forms.html#edef-TEXTAREA" title="HTML 4.01 Specification: `textarea` element" target="_blank" rel="external"><code>&amp;lt;textarea&amp;gt;</code></a>, <a href="http://www.w3.org/TR/html401/interact/forms.html#edef-FIELDSET" title="HTML 4.01 Specification: `fieldset` element" target="_blank" rel="external"><code>&amp;lt;fieldset&amp;gt;</code></a>, <a href="http://www.w3.org/TR/html401/interact/forms.html#edef-LEGEND" title="HTML 4.01 Specification: `legend` element" target="_blank" rel="external"><code>&amp;lt;legend&amp;gt;</code></a></li>
<li><code>&amp;lt;marquee&amp;gt;</code> (don’t ever use this one, non-standard and annoying)<br></li></ul></div><br>这个列表时不完善的。很多元素在微软的官方网站上没有提到，但是有一个方法很容易的测试到一个元素是否有layout，例如下代码：

<p>&lt;div id=”menu”&gt; … &lt;/div&gt;</p>
<p>为了判断这个div的haslayout属性值，我们可以在浏览器地址栏中输入如下代码：</p>
<p>javascript:alert(<strong>menu</strong>.currentStyle.hasLayout)</p>
<p>运行了这个代码之后就会反映出这个div的haslayout的属性值</p>
<p><strong>如何设置haslayout </strong></p>
<p>设置haslayout，换句话来说，就是给定一个布局，相对来说比haslayout等于false要简单。</p>
<p>以下属性和值将给定一个元素布局</p>
<div>

<ul>
<li><code>[position](http://w3.org/TR/CSS21/visuren.html#propdef-position &quot;CSS Specification:</code>position<code>property&quot;): absolute</code></li>
<li><code>[float](http://w3.org/TR/CSS21/visuren.html#propdef-float &quot;CSS Specification:</code>float<code>property&quot;): left</code> or <code>right</code></li>
<li><code>[display](http://w3.org/TR/CSS21/visuren.html#propdef-display &quot;CSS Specification:</code>display<code>property&quot;): inline-block</code></li>
<li><a href="http://w3.org/TR/CSS21/visudet.html#propdef-width" title="CSS Specification: `width` property" target="_blank" rel="external"><code>width</code></a>: <em>any</em> value <em>other</em> than <code>auto</code></li>
<li><a href="http://w3.org/TR/CSS21/visudet.html#propdef-height" title="CSS Specification: `height` property" target="_blank" rel="external"><code>height</code></a>: <em>any</em> value <em>other</em> than <code>auto</code></li>
<li><code>zoom</code>: <em>any</em> value <em>other</em> than <code>normal</code> (see <a href="http://haslayout.net/haslayout#zoomExplained" title="Skip to description of `zoom` property" target="_blank" rel="external">description</a> below)</li>
<li><code>writing-mode: tb-rl</code> (see <a href="http://haslayout.net/haslayout#zoomExplained" title="Skip to description of `writing-mode` property" target="_blank" rel="external">description</a> below)</li>
</ul>
<p>在ie7中, 也有一些属性 give “layout”:</p>
<ul>
<li><code>[overflow](http://w3.org/TR/CSS21/visufx.html#propdef-overflow &quot;CSS Specification:</code>overflow<code>property&quot;): hidden</code> or <code>scroll</code> or <code>auto</code></li>
<li><code>[overflow-x](http://www.w3.org/TR/css3-box/#overflow-x &quot;CSS3 Technical Report:</code>overflow-x<code>property&quot;): hidden</code> or <code>scroll</code> or <code>auto</code></li>
<li><code>[overflow-y](http://www.w3.org/TR/css3-box/#overflow-y &quot;CSS3 Technical Report:</code>oveflow-y<code>property&quot;): hidden</code> or <code>scroll</code> or <code>auto</code></li>
<li><a href="http://w3.org/TR/CSS21/visudet.html#propdef-min-width" title="CSS Specification: `min-width` property" target="_blank" rel="external"><code>min-width</code></a>: <em>any</em> value <em>other</em> than <code>auto</code></li>
<li><a href="http://w3.org/TR/CSS21/visudet.html#propdef-max-width" title="CSS Specification: `max-width` property" target="_blank" rel="external"><code>max-width</code></a>: <em>any</em> value <em>other</em> than <code>auto</code></li>
<li><a href="http://w3.org/TR/CSS21/visudet.html#propdef-min-height" title="CSS Specification: `min-height` property" target="_blank" rel="external"><code>min-height</code></a>: <em>any</em> value <em>other</em> than <code>auto</code></li>
<li><a href="http://w3.org/TR/CSS21/visudet.html#propdef-max-height" title="CSS Specification: `max-height` property" target="_blank" rel="external"><code>max-height</code></a>: <em>any</em> value <em>other</em> than <code>auto</code><br></li></ul></div><br>在ie8的标准模式中，微软已经废弃了haslayout属性了，但是在ie7的兼容模式中，仍然存在着这个属性。

<p>你可能对zoom 和write-mode这2个属性不太熟悉，他们都是微软的扩展属性。他们仅仅在ie中有效并且将来可能无效，因此我建议你把他们放入condcoms</p>
<p>write-mode属性在css3技术文档中已经出现了。zoom可能被提议，但是目前还没有。</p>
<p>zoom：1作者认为是最好的触发haslayout属性的组合，因为它对房前元素没有一点影响。</p>
<p>write-mode 就是字体排版布局的方式。</p>
<p>设置display：inline-block没有移除布局，这个技巧可以给元素设置成haslayout：true；</p>
<p>它相当于</p>
<p>div { display: inline-block; } div { display: block; }</p>
<p><span style="color: #29170d; font-family: 'Trebuchet MS', Arial, Helvetica, sans-serif;">设置</span>contenteditable也给一个元素设置成了haslayout：true。例如：&lt;p contenteditable=”true”&gt;so lame&lt;/p&gt;</p>
<p>你可能从来不用它来设置haslayout：true，写在这里只是为了一个信息的目的。不仅contenteditable是微软的一个属性，而且他还可以允许用户</p>
<p>编译元素的内容。这点有可能使用户困惑。</p>
<p>hasLayout 是一个可读的属性，不能通过js来修改它。</p>
<p><strong>我恨它 </strong></p>
<p>这听起来挺好的直到你碰到了一个bug并且把haslayout设置成true来解决。由于haslayout是可读的，所以不可能把它设置成一个false。幸运的</p>
<p>是，ie的很多bug都是由于元素没有设置成haslayout：true。</p>
<p><strong>bug </strong></p>
<p>在我的经验中，ie下的80% 的bug都是由于元素没有haslayout</p>
<p><abbr title="Internet Explorer">IE</abbr> hasLayout bugs经常出现各种很奇怪的问题，如果ie有些很难解释的问题，第一件事情要做的就是给该元素一个layout。</p>
<p>———END———-</p>
<p>&nbsp;</p>
<p><strong>本文原文地址：</strong><a href="http://www.cnblogs.com/yupeng/archive/2011/04/11/2012996.html" target="_blank" rel="external">http://www.cnblogs.com/yupeng/archive/2011/04/11/2012996.html</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-PHP函数的实现原理及性能分析 - 副本" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2013-02-22-PHP函数的实现原理及性能分析 - 副本.html" class="article-date">
      <time datetime="2013-02-22T03:40:27.000Z" itemprop="datePublished">2013-02-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2013-02-22-PHP函数的实现原理及性能分析 - 副本.html">PHP函数的实现原理及性能分析</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在任何语言中，函数都是最基本的组成单元。对于php的函数，它具有哪些特点？函数调用是怎么实现的？php函数的性能如何，有什么使用建议？本文将从原理出发进行分析结合实际的性能测试尝试对这些问题进行回答，在了解实现的同时更好的编写php程序。同时也会对一些常见的php函数进行介绍。</p>
<h2 id="php函数的分类"><a href="#php函数的分类" class="headerlink" title="php函数的分类"></a><a name="php函数的分类"></a>php函数的分类</h2><p>在php中，横向划分的话，函数分为两大类： user function(内置函数) 和internal function（内置函数）。前者就是用户在程序中自定义的一些函数和方法，后者则是php本身提供的各类库函数（比如sprintf、array_push等）。用户也可以通过扩展的方法来编写库函数，这个将在后面介绍。对于user function，又可以细分为function（<a href="http://phpe.net/tag/%e5%87%bd%e6%95%b0/" title="标签 函数 下的日志" target="_blank" rel="external">函数</a>）和method（类方法），本文中将就这三种函数分别进行分析和测试。</p>
<h2 id="php函数的实现"><a href="#php函数的实现" class="headerlink" title="php函数的实现"></a><a name="php函数的实现"></a>php函数的实现</h2><p>一个php函数最终是如何执行，这个流程是怎么样的呢？</p>
<p>要回答这个问题，我们先来看看php代码的执行所经过的流程。</p>
<p><a href="wp-content/uploads/2013/02/1.jpg"><img src="wp-content/uploads/2013/02/1.jpg" alt="php函数的实现" title="php函数的实现"></a></p>
<p>从图1可以看到，php实现了一个典型的动态语言执行过程：拿到一段代码后，经过词法解析、语法解析等阶段后，源程序会被翻译成一个个指令(opcodes)，然后ZEND虚拟机顺次执行这些指令完成操作。Php本身是用c实现的，因此最终调用的也都是c的函数，实际上，我们可以把php看做是一个c开发的软件。</p>
<p>通过上面描述不难看出，php中函数的执行也是被翻译成了opcodes来调用，每次函数调用实际上是执行了一条或多条指令。</p>
<p>对于每一个函数，zend都通过以下的数据结构来描述</p>
<pre style="margin: 15px 0; font: 100 12px/18px monaco, andale mono, courier new; padding: 10px 12px; border: #ccc 1px solid; border-left-width: 4px; background-color: #fefefe; box-shadow: 0 0 4px #eee; word-break: break-all; word-wrap: break-word; color: #444;"><span style="color: #555;">&lt;?php</span>
<span style="color: #@cm-word;">typedef</span> <span style="color: #@cm-word;">union</span> <span style="color: #@cm-word;">_zend_function</span> {
    <span style="color: #@cm-word;">zend_uchar</span> <span style="color: #@cm-word;">type</span>;    <span style="color: #a50;">/* MUST be the first element of this struct! */</span>
    <span style="color: #@cm-word;">struct</span> {
        <span style="color: #@cm-word;">zend_uchar</span> <span style="color: #@cm-word;">type</span>;  <span style="color: #a50;">/* never used */</span>
        <span style="color: #@cm-word;">char</span> <span style="color: #000;">*</span><span style="color: #@cm-word;">function_name</span>;
        <span style="color: #@cm-word;">zend_class_entry</span> <span style="color: #000;">*</span><span style="color: #@cm-word;">scope</span>;
        <span style="color: #@cm-word;">zend_uint</span> <span style="color: #@cm-word;">fn_flags</span>;
        <span style="color: #@cm-word;">union</span> <span style="color: #@cm-word;">_zend_function</span> <span style="color: #000;">*</span><span style="color: #@cm-word;">prototype</span>;
        <span style="color: #@cm-word;">zend_uint</span> <span style="color: #@cm-word;">num_args</span>;
        <span style="color: #@cm-word;">zend_uint</span> <span style="color: #@cm-word;">required_num_args</span>;
        <span style="color: #@cm-word;">zend_arg_info</span> <span style="color: #000;">*</span><span style="color: #@cm-word;">arg_info</span>;
        <span style="color: #@cm-word;">zend_bool</span> <span style="color: #@cm-word;">pass_rest_by_reference</span>;
        <span style="color: #@cm-word;">unsigned</span> <span style="color: #@cm-word;">char</span> <span style="color: #@cm-word;">return_reference</span>;
    } <span style="color: #@cm-word;">common</span>;

    <span style="color: #@cm-word;">zend_op_array</span> <span style="color: #@cm-word;">op_array</span>;
    <span style="color: #@cm-word;">zend_internal_function</span> <span style="color: #@cm-word;">internal_function</span>;
} <span style="color: #@cm-word;">zend_function</span>;

<span style="color: #@cm-word;">typedef</span> <span style="color: #@cm-word;">struct</span> <span style="color: #@cm-word;">_zend_function_state</span> {
    <span style="color: #@cm-word;">HashTable</span> <span style="color: #000;">*</span><span style="color: #@cm-word;">function_symbol_table</span>;
    <span style="color: #@cm-word;">zend_function</span> <span style="color: #000;">*</span><span style="color: #708;">function</span>;
    <span style="color: #@cm-word;">void</span> <span style="color: #000;">*</span><span style="color: #@cm-word;">reserved</span>[<span style="color: #@cm-word;">ZEND_MAX_RESERVED_RESOURCES</span>];
} <span style="color: #@cm-word;">zend_function_state</span>;
 <span style="color: #555;">?&gt;</span></pre>
<pre>其中type标明了函数的类型：用户函数、内置函数、重载函数。Common中包含函数的基本信息，包括函数名，</pre>
<pre>参数信息，函数标志（普通函数、静态方法、抽象方法）等内容。另外，对于用户函数，还有一个函数符号表，</pre>
<pre>记录了内部变量等，这个将在后面详述。 Zend维护了一个全局function_table，这是一个大的hahs表。</pre>
<pre>函数调用的时候会首先根据函数名从表中找到对应的zend_function。当进行函数调用时候，虚拟机会</pre>
<pre>根据type的不同决定调用方法， 不同类型的函数，其执行原理是不相同的 。</pre>

<h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a><a name="内置函数"></a>内置函数</h3><p>内置函数，其本质上就是真正的c函数，每一个内置函数，php在最终编译后都会展开成为一个名叫zif_xxxx的function，比如我们常见的sprintf，对应到底层就是zif_sprintf。Zend在执行的时候，如果发现是内置函数，则只是简单的做一个转发操作。</p>
<p>Zend提供了一系列的api供调用，包括参数获取、数组操作、内存分配等。内置函数的参数获取，通过zend_parse_parameters方法来实现，对于数组、字符串等参数，zend实现的是浅拷贝，因此这个效率是很高的。可以这样说，对于php内置函数，其效率和相应c函数几乎相同，唯一多了一次转发调用。</p>
<p>内置函数在php中都是通过so的方式进行动态加载，用户也可以根据需要自己编写相应的so，也就是我们常说的扩展。ZEND提供了一系列的api供扩展使用</p>
<h3 id="用户函数"><a href="#用户函数" class="headerlink" title="用户函数"></a><a name="用户函数"></a>用户函数</h3><p>和内置函数相比，用户通过php实现的自定义函数具有完全不同的执行过程和实现原理。如前文所述，我们知道php代码是被翻译成为了一条条opcode来执行的，用户函数也不例外，实际中每个函数对应到一组opcode，这组指令被保存在zend_function中。于是，用户函数的调用最终就是对应到一组opcodes的执行。</p>
<ul>
<li>局部变量的保存及递归的实现我们知道，函数递归是通过堆栈来完成的。在php中，也是利用类似的方法来实现。Zend为每个php函数分配了一个活动符号表(active_sym_table)，记录当前函数中所有局部变量的状态。所有的符号表通过堆栈的形式来维护，每当有函数调用的时候，分配一个新的符号表并入栈。当调用结束后当前符号表出栈。由此实现了状态的保存和递归。<br>对于栈的维护，zend在这里做了优化。预先分配一个长度为N的静态数组来模拟堆栈，这种通过静态数组来模拟动态数据结构的手法在我们自己的程序中也经常有使用，这种方式避免了每次调用带来的内存分配、销毁。ZEND只是在函数调用结束时将当前栈顶的符号表数据clean掉即可。</li>
</ul>
<p>因为静态数组长度为N，一旦函数调用层次超过N，程序不会出现栈溢出，这种情况下zend就会进行符号表的分配、销毁，因此会导致性能下降很多。在zend里面，N目前取值是32。因此，我们编写php程序的时候，函数调用层次最好不要超过32。当然，如果是web应用，本身可以函数调用层次的深度。</p>
<ul>
<li>参数的传递和内置函数调用zend_parse_params来获取参数不同，用户函数中参数的获取是通过指令来完成的。函数有几个参数就对应几条指令。具体到实现上就是普通的变量赋值。通过上面的分析可以看出，和内置函数相比，由于是自己维护堆栈表，而且每条指令的执行也是一个c函数，用户函数的性能相对会差很多，后面会有具体的对比分析。因此，如果一个功能有对应php内置函数实现的尽量不要自己重新写函数去实现。</li>
</ul>
<h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a><a name="类方法"></a>类方法</h3><p>类方法其执行原理和用户函数是相同的，也是翻译成opcodes顺次调用。类的实现，zend用一个数据结构zend_class_entry来实现，里面保存了类相关的一些基本信息。这个entry是在php编译的时候就已经处理完成。</p>
<p>在zend_function的common中，有一个成员叫做scope，其指向的就是当前方法对应类的zend_class_entry。关于php中面向对象的实现，这里就不在做更详细的介绍，今后将专门写一篇文章来详述php中面向对象的实现原理。就函数这一块来说，method实现原理和function完全相同，理论上其性能也差不多，后面我们将做详细的性能对比。</p>
<h2 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h2><h3 id="函数名长度对性能的影响"><a href="#函数名长度对性能的影响" class="headerlink" title="函数名长度对性能的影响"></a><a name="函数名长度对性能的影响"></a>函数名长度对性能的影响</h3><ul>
<li><p>测试方法对名字长度为1、2、4、8、16的函数进行比较，测试比较它们每秒可执行次数，确定函数名长度对性能的影响</p>
</li>
<li><p>测试结果如下图<a href="wp-content/uploads/2013/02/2.jpg"><img src="wp-content/uploads/2013/02/2.jpg" alt="函数名长度对性能的影响" title="函数名长度对性能的影响"></a></p>
</li>
<li><p>结果分析从图上可以看出，函数名的长度对性能还是会有一定的影响。一个长度为1的函数和长度为16的 <strong>空函数调用</strong> ，其性能差了1倍。分析一下源码不难找到原因，如前面叙述所说，函数调用的时候zend会先在一个全局的funtion_table中通过函数名查询相关信息，function_table是一个哈希表。必然的，名字越长查询所需要的时间就越多。 <strong>因此，在实际编写程序的时候，对多次调用的函数，名字建议不要太长</strong><br>虽然函数名长度对性能有一定影响，但具体有多大呢？这个问题应该还是需要结合实际情况来考虑，如果一个函数本身比较复杂的话，那么对整体的性能影响并不大。</p>
</li>
</ul>
<p>一个建议是对于那些会调用很多次，本身功能又比较简单的函数，可以适当取一些言简意赅的名字。</p>
<h3 id="函数个数对性能的影响"><a href="#函数个数对性能的影响" class="headerlink" title="函数个数对性能的影响"></a><a name="函数个数对性能的影响"></a>函数个数对性能的影响</h3><ul>
<li><p>测试方法在以下三种环境下进行函数调用测试，分析结果：1.程序仅包含1个函数 2.程序包含100个函数 3.程序包含1000个函数。测试这三种情况下每秒所能调用的函数次数</p>
</li>
<li><p>测试结果如下图<a href="wp-content/uploads/2013/02/3.jpg"><img src="wp-content/uploads/2013/02/3.jpg" alt="函数名长度对性能的影响" title="函数名长度对性能的影响"></a></p>
</li>
<li><p>结果分析从测试结果可以看出，这三种情况下性能几乎相同，函数个数增加时性能下降微乎其微，可以忽略。从实现原理分析，几种实现下唯一的区别在于函数获取的部分。如前文所述，所有的函数都放在一个hash表中，在不同个数下查找效率都应该还是接近于O(1)，所以性能差距不大。</p>
</li>
</ul>
<h3 id="不同类型函数调用消耗"><a href="#不同类型函数调用消耗" class="headerlink" title="不同类型函数调用消耗"></a><a name="不同类型函数调用消耗"></a>不同类型函数调用消耗</h3><ul>
<li><p>测试方法选取用户函数、类方法、静态方法、内置函数各一种，函数本身不做任何事情，直接返回，主要测试空函数调用的消耗。测试结果为每秒可执行次数测试中为去除其他影响，所有函数名字长度相同</p>
</li>
<li><p>测试结果如下图<a href="wp-content/uploads/2013/02/4.jpg"><img src="wp-content/uploads/2013/02/4.jpg" alt="不同类型函数调用消耗" title="不同类型函数调用消耗"></a></p>
</li>
<li><p>结果分析通过测试结果可以看到，对于用户自己编写的php函数，不管是哪种类型，其效率是差不多的，均在280w/s左右。如我们预期，即使是空调，内置函数其效率也要高很多，达到780w/s，是前者是3倍。可见，内置函数调用的开销还是远低于用户函数。从前面原理分析可知主要差距在于用户函数调用时初始化符号表、接收参数等操作。</p>
</li>
</ul>
<h3 id="内置函数和用户函数性能对比"><a href="#内置函数和用户函数性能对比" class="headerlink" title="内置函数和用户函数性能对比"></a><a name="内置函数和用户函数性能对比"></a>内置函数和用户函数性能对比</h3><ul>
<li><p>测试方法内置函数和用户函数的性能对比，这里我们选取几个常用的函数，然后用php实现相同功能的函数进行一下性能对比。测试中，我们选取字符串、数学、数组中各一个典型进行对比，这几个函数分别是字符串截取(substr)、10进制转2进制(decbin)、求最小值(min)和返回数组中的所以key(array_keys)。</p>
</li>
<li><p>测试结果如下图<a href="wp-content/uploads/2013/02/5.jpg"><img src="wp-content/uploads/2013/02/5.jpg" alt="内置函数和用户函数性能对比" title="内置函数和用户函数性能对比"></a></p>
</li>
<li><p>结果分析从测试结果可以看出，如我们预期，内置函数在总体性能上远高于普通用户函数。尤其对于涉及到字符串类操作的函数，差距达到了1个数量级。因此，函数使用的一个原则就是如果某功能有相应的内置函数，尽量使用它而不是自己编写php函数。对于一些涉及到大量字符串操作的功能，为提高性能，可以考虑用扩展来实现。比如常见的富文本过滤等。</p>
</li>
</ul>
<h3 id="和C函数性能对比"><a href="#和C函数性能对比" class="headerlink" title="和C函数性能对比"></a><a name="和C函数性能对比"></a>和C函数性能对比</h3><ul>
<li>测试方法我们选取字符串操作和算术运算各3种函数进行比对，php用扩展实现。三种函数是简单的一次算法运算、字符串比较和多次的算法运算。除了本身的两类函数外，还会测试将函数空调开销去掉后的性能，一方面比对一下两种函数（c和php内置）本身的性能差异，另外就是侧面印证空调函数的消耗</li>
</ul>
<p>测试点为执行10w次操作的时间消耗</p>
<ul>
<li><p>测试结果如下图<a href="wp-content/uploads/2013/02/6.jpg"><img src="wp-content/uploads/2013/02/6.jpg" alt="和C函数性能对比" title="和C函数性能对比"></a></p>
</li>
<li><p>结果分析内置函数和C函数的开销在去掉php函数空调用的影响后差距较小，随着函数功能越来越复杂，双方性能趋近于相同。这个从之前的函数实现分析中也容易得到论证，毕竟内置函数就是C实现的。函数功能越复杂，c和php的性能差距越小</p>
</li>
</ul>
<p>相对c来说，php函数调用的开销大很多，对于简单函数来说性能还是有一定影响。因此php中函数不宜嵌套封装太深。</p>
<h2 id="伪函数及其性能"><a href="#伪函数及其性能" class="headerlink" title="伪函数及其性能"></a><a name="伪函数及其性能"></a>伪函数及其性能</h2><p>在php中，有这样一些函数，它们在使用上是标准的函数用法，但底层实现却和真正函数调用完全不同，这些函数不属于前文提到的三种function中的任何一类，其实质是一条单独的opcode，这里估且叫做伪函数或者指令函数。</p>
<p>如上所说，伪函数使用起来和标准的函数并无二致，看起来具有相同的特征。但是他们最终执行的时候是被zend反映成了一条对应的指令（opcode）来调用，因此其实现更接近于if、for、算术运算等操作。</p>
<ul>
<li>php中的伪函数issetempty</li>
</ul>
<p>unset</p>
<p>eval<br>通过上面的介绍可以看出，伪函数由于被直接翻译成指令来执行，和普通函数相比少了一次函数调用所带来的开销，因此性能会更好一些。我们通过如下测试来做一个对比。 Array_key_exists和isset两者都可以判断数组中某个key是否存在，看一下他们的性能</p>
<p><a href="wp-content/uploads/2013/02/7.jpg"><img src="wp-content/uploads/2013/02/7.jpg" alt="伪函数及其性能" title="伪函数及其性能"></a></p>
<p>从图上可以看出，和array_key_exists相比，isset性能要高出很多，基本是前者的4倍左右，而即使是和空函数调用相比，其性能也要高出1倍左右。由此也侧面印证再次说明了php函数调用的开销还是比较大的。</p>
<h2 id="常用php函数实现及介绍"><a href="#常用php函数实现及介绍" class="headerlink" title="常用php函数实现及介绍"></a><a name="常用php函数实现及介绍"></a>常用php函数实现及介绍</h2><h3 id="count"><a href="#count" class="headerlink" title="count"></a><a name="count"></a>count</h3><p>count是我们经常用到的一个函数，其功能是返回一个数组的长度。</p>
<p>count这个函数，其复杂度是多少呢？</p>
<p>一种常见的说法是count函数会遍历整个数组然后求出元素个数，因此复杂度是O(n)。那实际情况是不是这样呢？</p>
<p>我们回到count的实现来看一下，通过源码可以发现，对于数组的count操作，函数最终的路径是zif_count-&gt; <a href="http://phpe.net/tag/php/" title="标签 php 下的日志" target="_blank" rel="external">php</a>_count_recursive-&gt; zend_hash_num_elements，而zend_hash_num_elements的行为是 return ht-&gt;nNumOfElements，可见，这是一个O(1)而不是O(n)的操作。实际上，数组在php底层就是一个hash_table，对于hash表，zend中专门有一个元素nNumOfElements记录了当前元素的个数，因此对于一般的count实际上直接就返回了这个值。由此，我们得出结论： <strong>count是O(1)的复杂度，和具体数组的大小无关。</strong></p>
<p>非数组类型的变量，count的行为时怎样？</p>
<p>对于未设置变量返回0，而像int、double、string等则会返回1</p>
<h3 id="strlen"><a href="#strlen" class="headerlink" title="strlen"></a><a name="strlen"></a>strlen</h3><p>Strlen用于返回一个字符串的长度。那么，他的实现原理是如何的呢？</p>
<p>我们都知道在c中strlen是一个o(n)的函数，会顺序遍历字符串直到遇到\0，然后出长度。Php中是否也这样呢？答案是否定的，php里字符串是用一个复合结构来描述，包括指向具体数据的指针和字符串长度（和c++中string类似），因此strlen就直接返回字符串长度了，是常数级别的操作。</p>
<p>另外，对于非字符串类型的变量调用strlen，它会首先将变量强制转换为字符串再求长度，这点需要注意。</p>
<h3 id="isset和array-key-exists"><a href="#isset和array-key-exists" class="headerlink" title="isset和array_key_exists"></a><a name="isset和array_key_exists"></a>isset和array_key_exists</h3><p>这两个函数最常见的用法都是判断一个key是否在数组中存在。但是前者还可以用于判断一个变量是否被设置过。</p>
<p>如前文所述，isset并非真正的函数，因此它的效率会比后者高很多。推荐用它代替array_key_exists。</p>
<h3 id="array-push和array"><a href="#array-push和array" class="headerlink" title="array_push和array[]"></a><a name="array_push和array[]"></a>array_push和array[]</h3><p>两者都是往数组尾部追加一个元素。不同的是前者可以一次push多个。他们最大的区别在于一个是函数一个是语言结构，因此后者效率要更高。因此如果只是普通的追加元素，建议使用array []。</p>
<h3 id="rand和mt-rand"><a href="#rand和mt-rand" class="headerlink" title="rand和mt_rand"></a><a name="rand和mt_rand"></a>rand和mt_rand</h3><p>两者都是提供产生随机数的功能，前者使用libc标准的rand。后者用了 Mersenne Twister 中已知的特性作为随机数发生器，它可以产生随机数值的平均速度比 libc 提供的 rand() 快四倍。因此如果对性能要求较高，可以考虑用mt_rand代替前者。</p>
<p>我们都知道，rand产生的是伪随机数，在C中需要用srand显示指定种子。但是在php中，rand会自己帮你默认调用一次srand，一般情况下不需要自己再显示的调用。</p>
<p>需要注意的是，如果特殊情况下需要调用srand时，一定要配套调用。就是说srand对于rand，mt_srand对应srand，切不可混合使用，否则是无效的。</p>
<h3 id="sort和usort"><a href="#sort和usort" class="headerlink" title="sort和usort"></a><a name="sort和usort"></a>sort和usort</h3><p>两者都是用于排序，不同的是前者可以指定排序策略，类似我们C里面的qsort和C++的sort。</p>
<p>在排序上两者都是采用标准的快排来实现，对于有排序需求的，如非特殊情况调用php提供的这些方法就可以了，不用自己重新实现一遍，效率会低很多。原因见前文对于用户函数和内置函数的分析比对。</p>
<h3 id="urlencode和rawurlencode"><a href="#urlencode和rawurlencode" class="headerlink" title="urlencode和rawurlencode"></a><a name="urlencode和rawurlencode"></a>urlencode和rawurlencode</h3><p>这两个都是用于url编码， 字符串中除了 -_. 之外的所有非字母数字字符都将被替换成百分号（%）后跟两位十六进制数。两者唯一的区别在于对于空格，urlencode会编码为+，而rawurlencode会编码为%20。</p>
<p>一般情况下除了搜索引擎，我们的策略都是空格编码为%20。因此采用后者的居多。</p>
<p>注意的是encode和decode系列一定要配套使用。</p>
<h3 id="strcmp系列函数"><a href="#strcmp系列函数" class="headerlink" title="strcmp系列函数"></a><a name="strcmp系列函数"></a>strcmp系列函数</h3><p>这一系列的函数包括strcmp、strncmp、strcasecmp、strncasecmp，实现功能和C函数相同。但也有不同，由于php的字符串是允许\0出现，因此在判断的时候底层使用的是memcmp系列而非strcmp，理论上来说更快。</p>
<p>另外由于php直接能获取到字符串长度，因此会首先这方面的检查，很多情况下效率就会高很多了。</p>
<h3 id="is-int和is-numeric"><a href="#is-int和is-numeric" class="headerlink" title="is_int和is_numeric"></a><a name="is_int和is_numeric"></a>is_int和is_numeric</h3><p>这两个函数功能相似又不完全相同，使用的时候一定需要注意他们的区别。</p>
<p>Is_int：判断一个变量类型是否是整数型，php变量中专门有一个字段表征类型，因此直接判断这个类型即可，是一个绝对O(1)的操作</p>
<p>Is_numeric：判断一个变量是否是整数或数字字符串，也就是说除了整数型变量会返回true之外，对于字符串变量，如果形如”1234”，”1e4”等也会被判为true。这个时候会遍历字符串进行判断。</p>
<h2 id="总结及建议"><a href="#总结及建议" class="headerlink" title="总结及建议"></a><a name="总结及建议"></a>总结及建议</h2><p><strong>通过对函数实现的原理分析和性能测试，我们总结出以下一些结论</strong></p>
<p>1． Php的函数调用开销相对较大。</p>
<p>2． 函数相关信息保存在一个大的hash_table中，每次调用时通过函数名在hash表中查找，因此函数名长度对性能也有一定影响。</p>
<p>3． 函数返回引用没有实际意义</p>
<p>4． 内置php函数性能比用户函数高很多，尤其对于字符串类操作。</p>
<p>5． 类方法、普通函数、静态方法效率几乎相同，没有太大差异</p>
<p>6． 除去空函数调用的影响，内置函数和同样功能的C函数性能基本差不多。</p>
<p>7． 所有的参数传递都是采用引用计数的浅拷贝，代价很小。</p>
<p>8． 函数个数对性能影响几乎可以忽略</p>
<p><strong>因此，对于php函数的使用，有如下一些建议</strong></p>
<p>1． 一个功能可以用内置函数完成，尽量使用它而不是自己编写php函数。</p>
<p>2． 如果某个功能对性能要求很高，可以考虑用扩展来实现。</p>
<p>3． Php函数调用开销较大，因此不要过分封装。有些功能，如果需要调用的次数很多本身又只用1、2行代码就行实现的，建议就不要封装调用了。</p>
<p>4． 不要过分迷恋各种设计模式，如上一条描述，过分的封装会带来性能的下降。需要考虑两者的权衡。Php有自己的特点，切不可东施效颦，过分效仿java的模式。</p>
<p>5． 函数不宜嵌套过深，递归使用要谨慎。</p>
<p>6． 伪函数性能很高，同等功能实现下优先考虑。比如用isset代替array_key_exists</p>
<p>7． 函数返回引用没有太大意义，也起不到实际作用，建议不予考虑。</p>
<p>8． 类成员方法效率不比普通函数低，因此不用担心性能损耗。建议多考虑静态方法，可读性及安全性都更好。</p>
<p>9． 如不是特殊需要，参数传递都建议使用传值而不是传引用。当然，如果参数是很大的数组且需要修改时可以考虑引用传递。</p>
<h4 id="转载出处：http-www-cnblogs-com-ghj1976-archive-2010-08-27-1809766-html"><a href="#转载出处：http-www-cnblogs-com-ghj1976-archive-2010-08-27-1809766-html" class="headerlink" title="转载出处：http://www.cnblogs.com/ghj1976/archive/2010/08/27/1809766.html"></a>转载出处：<a href="http://www.cnblogs.com/ghj1976/archive/2010/08/27/1809766.html" target="_blank" rel="external">http://www.cnblogs.com/ghj1976/archive/2010/08/27/1809766.html</a></h4>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-PHP函数的实现原理及性能分析" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2013-02-22-PHP函数的实现原理及性能分析.html" class="article-date">
      <time datetime="2013-02-22T03:40:27.000Z" itemprop="datePublished">2013-02-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2013-02-22-PHP函数的实现原理及性能分析.html">PHP函数的实现原理及性能分析</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在任何语言中，函数都是最基本的组成单元。对于php的函数，它具有哪些特点？函数调用是怎么实现的？php函数的性能如何，有什么使用建议？本文将从原理出发进行分析结合实际的性能测试尝试对这些问题进行回答，在了解实现的同时更好的编写php程序。同时也会对一些常见的php函数进行介绍。</p>
<h2 id="php函数的分类"><a href="#php函数的分类" class="headerlink" title="php函数的分类"></a><a name="php函数的分类"></a>php函数的分类</h2><p>在php中，横向划分的话，函数分为两大类： user function(内置函数) 和internal function（内置函数）。前者就是用户在程序中自定义的一些函数和方法，后者则是php本身提供的各类库函数（比如sprintf、array_push等）。用户也可以通过扩展的方法来编写库函数，这个将在后面介绍。对于user function，又可以细分为function（<a href="http://phpe.net/tag/%e5%87%bd%e6%95%b0/" title="标签 函数 下的日志" target="_blank" rel="external">函数</a>）和method（类方法），本文中将就这三种函数分别进行分析和测试。</p>
<h2 id="php函数的实现"><a href="#php函数的实现" class="headerlink" title="php函数的实现"></a><a name="php函数的实现"></a>php函数的实现</h2><p>一个php函数最终是如何执行，这个流程是怎么样的呢？</p>
<p>要回答这个问题，我们先来看看php代码的执行所经过的流程。</p>
<p><a href="wp-content/uploads/2013/02/1.jpg"><img src="wp-content/uploads/2013/02/1.jpg" alt="php函数的实现" title="php函数的实现"></a></p>
<p>从图1可以看到，php实现了一个典型的动态语言执行过程：拿到一段代码后，经过词法解析、语法解析等阶段后，源程序会被翻译成一个个指令(opcodes)，然后ZEND虚拟机顺次执行这些指令完成操作。Php本身是用c实现的，因此最终调用的也都是c的函数，实际上，我们可以把php看做是一个c开发的软件。</p>
<p>通过上面描述不难看出，php中函数的执行也是被翻译成了opcodes来调用，每次函数调用实际上是执行了一条或多条指令。</p>
<p>对于每一个函数，zend都通过以下的数据结构来描述</p>
<pre style="margin: 15px 0; font: 100 12px/18px monaco, andale mono, courier new; padding: 10px 12px; border: #ccc 1px solid; border-left-width: 4px; background-color: #fefefe; box-shadow: 0 0 4px #eee; word-break: break-all; word-wrap: break-word; color: #444;"><span style="color: #555;">&lt;?php</span>
<span style="color: #@cm-word;">typedef</span> <span style="color: #@cm-word;">union</span> <span style="color: #@cm-word;">_zend_function</span> {
    <span style="color: #@cm-word;">zend_uchar</span> <span style="color: #@cm-word;">type</span>;    <span style="color: #a50;">/* MUST be the first element of this struct! */</span>
    <span style="color: #@cm-word;">struct</span> {
        <span style="color: #@cm-word;">zend_uchar</span> <span style="color: #@cm-word;">type</span>;  <span style="color: #a50;">/* never used */</span>
        <span style="color: #@cm-word;">char</span> <span style="color: #000;">*</span><span style="color: #@cm-word;">function_name</span>;
        <span style="color: #@cm-word;">zend_class_entry</span> <span style="color: #000;">*</span><span style="color: #@cm-word;">scope</span>;
        <span style="color: #@cm-word;">zend_uint</span> <span style="color: #@cm-word;">fn_flags</span>;
        <span style="color: #@cm-word;">union</span> <span style="color: #@cm-word;">_zend_function</span> <span style="color: #000;">*</span><span style="color: #@cm-word;">prototype</span>;
        <span style="color: #@cm-word;">zend_uint</span> <span style="color: #@cm-word;">num_args</span>;
        <span style="color: #@cm-word;">zend_uint</span> <span style="color: #@cm-word;">required_num_args</span>;
        <span style="color: #@cm-word;">zend_arg_info</span> <span style="color: #000;">*</span><span style="color: #@cm-word;">arg_info</span>;
        <span style="color: #@cm-word;">zend_bool</span> <span style="color: #@cm-word;">pass_rest_by_reference</span>;
        <span style="color: #@cm-word;">unsigned</span> <span style="color: #@cm-word;">char</span> <span style="color: #@cm-word;">return_reference</span>;
    } <span style="color: #@cm-word;">common</span>;

    <span style="color: #@cm-word;">zend_op_array</span> <span style="color: #@cm-word;">op_array</span>;
    <span style="color: #@cm-word;">zend_internal_function</span> <span style="color: #@cm-word;">internal_function</span>;
} <span style="color: #@cm-word;">zend_function</span>;

<span style="color: #@cm-word;">typedef</span> <span style="color: #@cm-word;">struct</span> <span style="color: #@cm-word;">_zend_function_state</span> {
    <span style="color: #@cm-word;">HashTable</span> <span style="color: #000;">*</span><span style="color: #@cm-word;">function_symbol_table</span>;
    <span style="color: #@cm-word;">zend_function</span> <span style="color: #000;">*</span><span style="color: #708;">function</span>;
    <span style="color: #@cm-word;">void</span> <span style="color: #000;">*</span><span style="color: #@cm-word;">reserved</span>[<span style="color: #@cm-word;">ZEND_MAX_RESERVED_RESOURCES</span>];
} <span style="color: #@cm-word;">zend_function_state</span>;
 <span style="color: #555;">?&gt;</span></pre>
<pre>其中type标明了函数的类型：用户函数、内置函数、重载函数。Common中包含函数的基本信息，包括函数名，</pre>
<pre>参数信息，函数标志（普通函数、静态方法、抽象方法）等内容。另外，对于用户函数，还有一个函数符号表，</pre>
<pre>记录了内部变量等，这个将在后面详述。 Zend维护了一个全局function_table，这是一个大的hahs表。</pre>
<pre>函数调用的时候会首先根据函数名从表中找到对应的zend_function。当进行函数调用时候，虚拟机会</pre>
<pre>根据type的不同决定调用方法， 不同类型的函数，其执行原理是不相同的 。</pre>

<h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a><a name="内置函数"></a>内置函数</h3><p>内置函数，其本质上就是真正的c函数，每一个内置函数，php在最终编译后都会展开成为一个名叫zif_xxxx的function，比如我们常见的sprintf，对应到底层就是zif_sprintf。Zend在执行的时候，如果发现是内置函数，则只是简单的做一个转发操作。</p>
<p>Zend提供了一系列的api供调用，包括参数获取、数组操作、内存分配等。内置函数的参数获取，通过zend_parse_parameters方法来实现，对于数组、字符串等参数，zend实现的是浅拷贝，因此这个效率是很高的。可以这样说，对于php内置函数，其效率和相应c函数几乎相同，唯一多了一次转发调用。</p>
<p>内置函数在php中都是通过so的方式进行动态加载，用户也可以根据需要自己编写相应的so，也就是我们常说的扩展。ZEND提供了一系列的api供扩展使用</p>
<h3 id="用户函数"><a href="#用户函数" class="headerlink" title="用户函数"></a><a name="用户函数"></a>用户函数</h3><p>和内置函数相比，用户通过php实现的自定义函数具有完全不同的执行过程和实现原理。如前文所述，我们知道php代码是被翻译成为了一条条opcode来执行的，用户函数也不例外，实际中每个函数对应到一组opcode，这组指令被保存在zend_function中。于是，用户函数的调用最终就是对应到一组opcodes的执行。</p>
<ul>
<li>局部变量的保存及递归的实现我们知道，函数递归是通过堆栈来完成的。在php中，也是利用类似的方法来实现。Zend为每个php函数分配了一个活动符号表(active_sym_table)，记录当前函数中所有局部变量的状态。所有的符号表通过堆栈的形式来维护，每当有函数调用的时候，分配一个新的符号表并入栈。当调用结束后当前符号表出栈。由此实现了状态的保存和递归。<br>对于栈的维护，zend在这里做了优化。预先分配一个长度为N的静态数组来模拟堆栈，这种通过静态数组来模拟动态数据结构的手法在我们自己的程序中也经常有使用，这种方式避免了每次调用带来的内存分配、销毁。ZEND只是在函数调用结束时将当前栈顶的符号表数据clean掉即可。</li>
</ul>
<p>因为静态数组长度为N，一旦函数调用层次超过N，程序不会出现栈溢出，这种情况下zend就会进行符号表的分配、销毁，因此会导致性能下降很多。在zend里面，N目前取值是32。因此，我们编写php程序的时候，函数调用层次最好不要超过32。当然，如果是web应用，本身可以函数调用层次的深度。</p>
<ul>
<li>参数的传递和内置函数调用zend_parse_params来获取参数不同，用户函数中参数的获取是通过指令来完成的。函数有几个参数就对应几条指令。具体到实现上就是普通的变量赋值。通过上面的分析可以看出，和内置函数相比，由于是自己维护堆栈表，而且每条指令的执行也是一个c函数，用户函数的性能相对会差很多，后面会有具体的对比分析。因此，如果一个功能有对应php内置函数实现的尽量不要自己重新写函数去实现。</li>
</ul>
<h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a><a name="类方法"></a>类方法</h3><p>类方法其执行原理和用户函数是相同的，也是翻译成opcodes顺次调用。类的实现，zend用一个数据结构zend_class_entry来实现，里面保存了类相关的一些基本信息。这个entry是在php编译的时候就已经处理完成。</p>
<p>在zend_function的common中，有一个成员叫做scope，其指向的就是当前方法对应类的zend_class_entry。关于php中面向对象的实现，这里就不在做更详细的介绍，今后将专门写一篇文章来详述php中面向对象的实现原理。就函数这一块来说，method实现原理和function完全相同，理论上其性能也差不多，后面我们将做详细的性能对比。</p>
<h2 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h2><h3 id="函数名长度对性能的影响"><a href="#函数名长度对性能的影响" class="headerlink" title="函数名长度对性能的影响"></a><a name="函数名长度对性能的影响"></a>函数名长度对性能的影响</h3><ul>
<li><p>测试方法对名字长度为1、2、4、8、16的函数进行比较，测试比较它们每秒可执行次数，确定函数名长度对性能的影响</p>
</li>
<li><p>测试结果如下图<a href="wp-content/uploads/2013/02/2.jpg"><img src="wp-content/uploads/2013/02/2.jpg" alt="函数名长度对性能的影响" title="函数名长度对性能的影响"></a></p>
</li>
<li><p>结果分析从图上可以看出，函数名的长度对性能还是会有一定的影响。一个长度为1的函数和长度为16的 <strong>空函数调用</strong> ，其性能差了1倍。分析一下源码不难找到原因，如前面叙述所说，函数调用的时候zend会先在一个全局的funtion_table中通过函数名查询相关信息，function_table是一个哈希表。必然的，名字越长查询所需要的时间就越多。 <strong>因此，在实际编写程序的时候，对多次调用的函数，名字建议不要太长</strong><br>虽然函数名长度对性能有一定影响，但具体有多大呢？这个问题应该还是需要结合实际情况来考虑，如果一个函数本身比较复杂的话，那么对整体的性能影响并不大。</p>
</li>
</ul>
<p>一个建议是对于那些会调用很多次，本身功能又比较简单的函数，可以适当取一些言简意赅的名字。</p>
<h3 id="函数个数对性能的影响"><a href="#函数个数对性能的影响" class="headerlink" title="函数个数对性能的影响"></a><a name="函数个数对性能的影响"></a>函数个数对性能的影响</h3><ul>
<li><p>测试方法在以下三种环境下进行函数调用测试，分析结果：1.程序仅包含1个函数 2.程序包含100个函数 3.程序包含1000个函数。测试这三种情况下每秒所能调用的函数次数</p>
</li>
<li><p>测试结果如下图<a href="wp-content/uploads/2013/02/3.jpg"><img src="wp-content/uploads/2013/02/3.jpg" alt="函数名长度对性能的影响" title="函数名长度对性能的影响"></a></p>
</li>
<li><p>结果分析从测试结果可以看出，这三种情况下性能几乎相同，函数个数增加时性能下降微乎其微，可以忽略。从实现原理分析，几种实现下唯一的区别在于函数获取的部分。如前文所述，所有的函数都放在一个hash表中，在不同个数下查找效率都应该还是接近于O(1)，所以性能差距不大。</p>
</li>
</ul>
<h3 id="不同类型函数调用消耗"><a href="#不同类型函数调用消耗" class="headerlink" title="不同类型函数调用消耗"></a><a name="不同类型函数调用消耗"></a>不同类型函数调用消耗</h3><ul>
<li><p>测试方法选取用户函数、类方法、静态方法、内置函数各一种，函数本身不做任何事情，直接返回，主要测试空函数调用的消耗。测试结果为每秒可执行次数测试中为去除其他影响，所有函数名字长度相同</p>
</li>
<li><p>测试结果如下图<a href="wp-content/uploads/2013/02/4.jpg"><img src="wp-content/uploads/2013/02/4.jpg" alt="不同类型函数调用消耗" title="不同类型函数调用消耗"></a></p>
</li>
<li><p>结果分析通过测试结果可以看到，对于用户自己编写的php函数，不管是哪种类型，其效率是差不多的，均在280w/s左右。如我们预期，即使是空调，内置函数其效率也要高很多，达到780w/s，是前者是3倍。可见，内置函数调用的开销还是远低于用户函数。从前面原理分析可知主要差距在于用户函数调用时初始化符号表、接收参数等操作。</p>
</li>
</ul>
<h3 id="内置函数和用户函数性能对比"><a href="#内置函数和用户函数性能对比" class="headerlink" title="内置函数和用户函数性能对比"></a><a name="内置函数和用户函数性能对比"></a>内置函数和用户函数性能对比</h3><ul>
<li><p>测试方法内置函数和用户函数的性能对比，这里我们选取几个常用的函数，然后用php实现相同功能的函数进行一下性能对比。测试中，我们选取字符串、数学、数组中各一个典型进行对比，这几个函数分别是字符串截取(substr)、10进制转2进制(decbin)、求最小值(min)和返回数组中的所以key(array_keys)。</p>
</li>
<li><p>测试结果如下图<a href="wp-content/uploads/2013/02/5.jpg"><img src="wp-content/uploads/2013/02/5.jpg" alt="内置函数和用户函数性能对比" title="内置函数和用户函数性能对比"></a></p>
</li>
<li><p>结果分析从测试结果可以看出，如我们预期，内置函数在总体性能上远高于普通用户函数。尤其对于涉及到字符串类操作的函数，差距达到了1个数量级。因此，函数使用的一个原则就是如果某功能有相应的内置函数，尽量使用它而不是自己编写php函数。对于一些涉及到大量字符串操作的功能，为提高性能，可以考虑用扩展来实现。比如常见的富文本过滤等。</p>
</li>
</ul>
<h3 id="和C函数性能对比"><a href="#和C函数性能对比" class="headerlink" title="和C函数性能对比"></a><a name="和C函数性能对比"></a>和C函数性能对比</h3><ul>
<li>测试方法我们选取字符串操作和算术运算各3种函数进行比对，php用扩展实现。三种函数是简单的一次算法运算、字符串比较和多次的算法运算。除了本身的两类函数外，还会测试将函数空调开销去掉后的性能，一方面比对一下两种函数（c和php内置）本身的性能差异，另外就是侧面印证空调函数的消耗</li>
</ul>
<p>测试点为执行10w次操作的时间消耗</p>
<ul>
<li><p>测试结果如下图<a href="wp-content/uploads/2013/02/6.jpg"><img src="wp-content/uploads/2013/02/6.jpg" alt="和C函数性能对比" title="和C函数性能对比"></a></p>
</li>
<li><p>结果分析内置函数和C函数的开销在去掉php函数空调用的影响后差距较小，随着函数功能越来越复杂，双方性能趋近于相同。这个从之前的函数实现分析中也容易得到论证，毕竟内置函数就是C实现的。函数功能越复杂，c和php的性能差距越小</p>
</li>
</ul>
<p>相对c来说，php函数调用的开销大很多，对于简单函数来说性能还是有一定影响。因此php中函数不宜嵌套封装太深。</p>
<h2 id="伪函数及其性能"><a href="#伪函数及其性能" class="headerlink" title="伪函数及其性能"></a><a name="伪函数及其性能"></a>伪函数及其性能</h2><p>在php中，有这样一些函数，它们在使用上是标准的函数用法，但底层实现却和真正函数调用完全不同，这些函数不属于前文提到的三种function中的任何一类，其实质是一条单独的opcode，这里估且叫做伪函数或者指令函数。</p>
<p>如上所说，伪函数使用起来和标准的函数并无二致，看起来具有相同的特征。但是他们最终执行的时候是被zend反映成了一条对应的指令（opcode）来调用，因此其实现更接近于if、for、算术运算等操作。</p>
<ul>
<li>php中的伪函数issetempty</li>
</ul>
<p>unset</p>
<p>eval<br>通过上面的介绍可以看出，伪函数由于被直接翻译成指令来执行，和普通函数相比少了一次函数调用所带来的开销，因此性能会更好一些。我们通过如下测试来做一个对比。 Array_key_exists和isset两者都可以判断数组中某个key是否存在，看一下他们的性能</p>
<p><a href="wp-content/uploads/2013/02/7.jpg"><img src="wp-content/uploads/2013/02/7.jpg" alt="伪函数及其性能" title="伪函数及其性能"></a></p>
<p>从图上可以看出，和array_key_exists相比，isset性能要高出很多，基本是前者的4倍左右，而即使是和空函数调用相比，其性能也要高出1倍左右。由此也侧面印证再次说明了php函数调用的开销还是比较大的。</p>
<h2 id="常用php函数实现及介绍"><a href="#常用php函数实现及介绍" class="headerlink" title="常用php函数实现及介绍"></a><a name="常用php函数实现及介绍"></a>常用php函数实现及介绍</h2><h3 id="count"><a href="#count" class="headerlink" title="count"></a><a name="count"></a>count</h3><p>count是我们经常用到的一个函数，其功能是返回一个数组的长度。</p>
<p>count这个函数，其复杂度是多少呢？</p>
<p>一种常见的说法是count函数会遍历整个数组然后求出元素个数，因此复杂度是O(n)。那实际情况是不是这样呢？</p>
<p>我们回到count的实现来看一下，通过源码可以发现，对于数组的count操作，函数最终的路径是zif_count-&gt; <a href="http://phpe.net/tag/php/" title="标签 php 下的日志" target="_blank" rel="external">php</a>_count_recursive-&gt; zend_hash_num_elements，而zend_hash_num_elements的行为是 return ht-&gt;nNumOfElements，可见，这是一个O(1)而不是O(n)的操作。实际上，数组在php底层就是一个hash_table，对于hash表，zend中专门有一个元素nNumOfElements记录了当前元素的个数，因此对于一般的count实际上直接就返回了这个值。由此，我们得出结论： <strong>count是O(1)的复杂度，和具体数组的大小无关。</strong></p>
<p>非数组类型的变量，count的行为时怎样？</p>
<p>对于未设置变量返回0，而像int、double、string等则会返回1</p>
<h3 id="strlen"><a href="#strlen" class="headerlink" title="strlen"></a><a name="strlen"></a>strlen</h3><p>Strlen用于返回一个字符串的长度。那么，他的实现原理是如何的呢？</p>
<p>我们都知道在c中strlen是一个o(n)的函数，会顺序遍历字符串直到遇到\0，然后出长度。Php中是否也这样呢？答案是否定的，php里字符串是用一个复合结构来描述，包括指向具体数据的指针和字符串长度（和c++中string类似），因此strlen就直接返回字符串长度了，是常数级别的操作。</p>
<p>另外，对于非字符串类型的变量调用strlen，它会首先将变量强制转换为字符串再求长度，这点需要注意。</p>
<h3 id="isset和array-key-exists"><a href="#isset和array-key-exists" class="headerlink" title="isset和array_key_exists"></a><a name="isset和array_key_exists"></a>isset和array_key_exists</h3><p>这两个函数最常见的用法都是判断一个key是否在数组中存在。但是前者还可以用于判断一个变量是否被设置过。</p>
<p>如前文所述，isset并非真正的函数，因此它的效率会比后者高很多。推荐用它代替array_key_exists。</p>
<h3 id="array-push和array"><a href="#array-push和array" class="headerlink" title="array_push和array[]"></a><a name="array_push和array[]"></a>array_push和array[]</h3><p>两者都是往数组尾部追加一个元素。不同的是前者可以一次push多个。他们最大的区别在于一个是函数一个是语言结构，因此后者效率要更高。因此如果只是普通的追加元素，建议使用array []。</p>
<h3 id="rand和mt-rand"><a href="#rand和mt-rand" class="headerlink" title="rand和mt_rand"></a><a name="rand和mt_rand"></a>rand和mt_rand</h3><p>两者都是提供产生随机数的功能，前者使用libc标准的rand。后者用了 Mersenne Twister 中已知的特性作为随机数发生器，它可以产生随机数值的平均速度比 libc 提供的 rand() 快四倍。因此如果对性能要求较高，可以考虑用mt_rand代替前者。</p>
<p>我们都知道，rand产生的是伪随机数，在C中需要用srand显示指定种子。但是在php中，rand会自己帮你默认调用一次srand，一般情况下不需要自己再显示的调用。</p>
<p>需要注意的是，如果特殊情况下需要调用srand时，一定要配套调用。就是说srand对于rand，mt_srand对应srand，切不可混合使用，否则是无效的。</p>
<h3 id="sort和usort"><a href="#sort和usort" class="headerlink" title="sort和usort"></a><a name="sort和usort"></a>sort和usort</h3><p>两者都是用于排序，不同的是前者可以指定排序策略，类似我们C里面的qsort和C++的sort。</p>
<p>在排序上两者都是采用标准的快排来实现，对于有排序需求的，如非特殊情况调用php提供的这些方法就可以了，不用自己重新实现一遍，效率会低很多。原因见前文对于用户函数和内置函数的分析比对。</p>
<h3 id="urlencode和rawurlencode"><a href="#urlencode和rawurlencode" class="headerlink" title="urlencode和rawurlencode"></a><a name="urlencode和rawurlencode"></a>urlencode和rawurlencode</h3><p>这两个都是用于url编码， 字符串中除了 -_. 之外的所有非字母数字字符都将被替换成百分号（%）后跟两位十六进制数。两者唯一的区别在于对于空格，urlencode会编码为+，而rawurlencode会编码为%20。</p>
<p>一般情况下除了搜索引擎，我们的策略都是空格编码为%20。因此采用后者的居多。</p>
<p>注意的是encode和decode系列一定要配套使用。</p>
<h3 id="strcmp系列函数"><a href="#strcmp系列函数" class="headerlink" title="strcmp系列函数"></a><a name="strcmp系列函数"></a>strcmp系列函数</h3><p>这一系列的函数包括strcmp、strncmp、strcasecmp、strncasecmp，实现功能和C函数相同。但也有不同，由于php的字符串是允许\0出现，因此在判断的时候底层使用的是memcmp系列而非strcmp，理论上来说更快。</p>
<p>另外由于php直接能获取到字符串长度，因此会首先这方面的检查，很多情况下效率就会高很多了。</p>
<h3 id="is-int和is-numeric"><a href="#is-int和is-numeric" class="headerlink" title="is_int和is_numeric"></a><a name="is_int和is_numeric"></a>is_int和is_numeric</h3><p>这两个函数功能相似又不完全相同，使用的时候一定需要注意他们的区别。</p>
<p>Is_int：判断一个变量类型是否是整数型，php变量中专门有一个字段表征类型，因此直接判断这个类型即可，是一个绝对O(1)的操作</p>
<p>Is_numeric：判断一个变量是否是整数或数字字符串，也就是说除了整数型变量会返回true之外，对于字符串变量，如果形如”1234”，”1e4”等也会被判为true。这个时候会遍历字符串进行判断。</p>
<h2 id="总结及建议"><a href="#总结及建议" class="headerlink" title="总结及建议"></a><a name="总结及建议"></a>总结及建议</h2><p><strong>通过对函数实现的原理分析和性能测试，我们总结出以下一些结论</strong></p>
<p>1． Php的函数调用开销相对较大。</p>
<p>2． 函数相关信息保存在一个大的hash_table中，每次调用时通过函数名在hash表中查找，因此函数名长度对性能也有一定影响。</p>
<p>3． 函数返回引用没有实际意义</p>
<p>4． 内置php函数性能比用户函数高很多，尤其对于字符串类操作。</p>
<p>5． 类方法、普通函数、静态方法效率几乎相同，没有太大差异</p>
<p>6． 除去空函数调用的影响，内置函数和同样功能的C函数性能基本差不多。</p>
<p>7． 所有的参数传递都是采用引用计数的浅拷贝，代价很小。</p>
<p>8． 函数个数对性能影响几乎可以忽略</p>
<p><strong>因此，对于php函数的使用，有如下一些建议</strong></p>
<p>1． 一个功能可以用内置函数完成，尽量使用它而不是自己编写php函数。</p>
<p>2． 如果某个功能对性能要求很高，可以考虑用扩展来实现。</p>
<p>3． Php函数调用开销较大，因此不要过分封装。有些功能，如果需要调用的次数很多本身又只用1、2行代码就行实现的，建议就不要封装调用了。</p>
<p>4． 不要过分迷恋各种设计模式，如上一条描述，过分的封装会带来性能的下降。需要考虑两者的权衡。Php有自己的特点，切不可东施效颦，过分效仿java的模式。</p>
<p>5． 函数不宜嵌套过深，递归使用要谨慎。</p>
<p>6． 伪函数性能很高，同等功能实现下优先考虑。比如用isset代替array_key_exists</p>
<p>7． 函数返回引用没有太大意义，也起不到实际作用，建议不予考虑。</p>
<p>8． 类成员方法效率不比普通函数低，因此不用担心性能损耗。建议多考虑静态方法，可读性及安全性都更好。</p>
<p>9． 如不是特殊需要，参数传递都建议使用传值而不是传引用。当然，如果参数是很大的数组且需要修改时可以考虑引用传递。</p>
<h4 id="转载出处：http-www-cnblogs-com-ghj1976-archive-2010-08-27-1809766-html"><a href="#转载出处：http-www-cnblogs-com-ghj1976-archive-2010-08-27-1809766-html" class="headerlink" title="转载出处：http://www.cnblogs.com/ghj1976/archive/2010/08/27/1809766.html"></a>转载出处：<a href="http://www.cnblogs.com/ghj1976/archive/2010/08/27/1809766.html" target="_blank" rel="external">http://www.cnblogs.com/ghj1976/archive/2010/08/27/1809766.html</a></h4>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-纯CSS图标集(各浏览器下效果良好的) - 副本" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2013-02-06-纯CSS图标集(各浏览器下效果良好的) - 副本.html" class="article-date">
      <time datetime="2013-02-06T03:42:05.000Z" itemprop="datePublished">2013-02-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2013-02-06-纯CSS图标集(各浏览器下效果良好的) - 副本.html">纯CSS图标集(各浏览器下效果良好的)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>这里分享一个纯css图标集。使用纯css图标可以尽可能减少http请求，不需要任何图片。这里包含多个16*16尺寸的图标。当然更多尺寸的图标可以通过修改css代码来实现。</p>
<p>如果你需要使用图标，而又不想用图片，而恰好这套图标的风格接近，那么偷懒一下吧！源码去下面的Demo里面拿吧！</p>
<p><strong>现代浏览器下效果：</strong></p>
<p><img src="wp-content/uploads/2013/02/icon-peculiar.png" alt="" title="icon-peculiar"></p>
<p><strong>IE7、IE6等浏览器下效果：</strong></p>
<p><img src="wp-content/uploads/2013/02/icon-peculiar-ie6.png" alt="" title="icon-peculiar-ie6"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-纯CSS图标集(各浏览器下效果良好的)" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2013-02-06-纯CSS图标集(各浏览器下效果良好的).html" class="article-date">
      <time datetime="2013-02-06T03:42:05.000Z" itemprop="datePublished">2013-02-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2013-02-06-纯CSS图标集(各浏览器下效果良好的).html">纯CSS图标集(各浏览器下效果良好的)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>这里分享一个纯css图标集。使用纯css图标可以尽可能减少http请求，不需要任何图片。这里包含多个16*16尺寸的图标。当然更多尺寸的图标可以通过修改css代码来实现。</p>
<p>如果你需要使用图标，而又不想用图片，而恰好这套图标的风格接近，那么偷懒一下吧！源码去下面的Demo里面拿吧！</p>
<p><strong>现代浏览器下效果：</strong></p>
<p><img src="wp-content/uploads/2013/02/icon-peculiar.png" alt="" title="icon-peculiar"></p>
<p><strong>IE7、IE6等浏览器下效果：</strong></p>
<p><img src="wp-content/uploads/2013/02/icon-peculiar-ie6.png" alt="" title="icon-peculiar-ie6"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-腾讯TGideas招聘高级视觉设计师、高级重构工程师" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2013-01-08-腾讯TGideas招聘高级视觉设计师、高级重构工程师.html" class="article-date">
      <time datetime="2013-01-08T03:56:27.000Z" itemprop="datePublished">2013-01-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2013-01-08-腾讯TGideas招聘高级视觉设计师、高级重构工程师.html">腾讯TGideas招聘高级视觉设计师、高级重构工程师</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id=""><a href="#" class="headerlink" title=""></a><img src="wp-content/uploads/2013/01/TGideas-job-2013.jpg" alt=""></h2><div>你一手的好技法，却寻不着空间施展？</div><br><div>你满脑的妙点子，却找不到项目释放？</div><br><div>你浑身的游戏细菌，却碰不上神级队友结伴疯狂？</div><br><div>这里！TGideas！激情放纵的工作环境，热血恣肆的玩乐天堂，我们用多门类的专业人才已为你搭建好最专注的创作平台！</div><br><div>2013年，数款年度游戏巨作，诸多发展机会，只差设计强人！</div>

<h3 id="招聘岗位：高级视觉设计师（5名）"><a href="#招聘岗位：高级视觉设计师（5名）" class="headerlink" title="招聘岗位：高级视觉设计师（5名）"></a>招聘岗位：高级视觉设计师（5名）</h3><h4 id="岗位描述："><a href="#岗位描述：" class="headerlink" title="岗位描述："></a>岗位描述：</h4><p>隶属于腾讯公司互动娱乐业务系统市场部，负责游戏产品网站视觉表现以及其他相关推广类美术设计工作。</p>
<h4 id="职位要求："><a href="#职位要求：" class="headerlink" title="职位要求："></a>职位要求：</h4><ul>
<li>有较丰富游戏经验，熟悉国内外游戏行业动态，对游戏美术、动漫等领域有系统的了解，在游戏视觉表现力方面有较深认识；</li>
<li>同市场、产品相关人员讨论产品核心卖点，并给予有效的视觉设计策略支持，能够主导重点项目的视觉设计方向， 并完成主要视觉设计工作；</li>
<li>三年以上视觉设计从业经验；</li>
<li>有较好的专业知识广度，能够结合自身设计经验，根据业务需求推动方法论建设以及相关研究工作；</li>
<li>熟练操作相关设计软件（PS,AI），熟悉FLASH，Dreamweaver等软件者最佳；</li>
<li>良好的项目管理和沟通表达能力，对行业内的成本构成与业务规范有深入了解；</li>
<li>善于沟通，关注用户体验细节，有较强理解力与出色的沟通能力同时具备优秀的视觉表现能力。<br><div>简历投放地址：</div><br>tgideas@qq.com<br><div><br><div>工作地点：深圳、上海</div><div>

</div></div></li>
</ul>
<h3 id="招聘岗位：高级网页重构工程师（5名）"><a href="#招聘岗位：高级网页重构工程师（5名）" class="headerlink" title="招聘岗位：高级网页重构工程师（5名）"></a>招聘岗位：高级网页重构工程师（5名）</h3><h4 id="岗位描述：-1"><a href="#岗位描述：-1" class="headerlink" title="岗位描述："></a>岗位描述：</h4><p>隶属于腾讯公司互动娱乐业务系统市场部，负责游戏产品官网搭建、日常专题制作维护以及配合开发人员对功能型页面程序进行联调整合。</p>
<h4 id="职位要求：-1"><a href="#职位要求：-1" class="headerlink" title="职位要求："></a>职位要求：</h4><p><br></p>
<ul>
<li>从事3年以上网页重构工作，有相关行业经验者优先；</li>
<li>优秀的项目管理和沟通表达能力；</li>
<li>热爱游戏行业，能接受挑战并承受工作压力；</li>
<li>熟练使用DW，PS等网页制作及图片处理工具，并能手写代码；</li>
<li>精通XHTML语言和网页优化技巧，能快速构建出兼容主流浏览器的页面；</li>
<li>熟悉JS、JQ等前端开发语言，能完成基础的前端开发工作；</li>
<li>了解CGI、PHP等后台开发语言，能配合开发人员进行页面联调整合；</li>
<li>对于html5、css3、多终端等新技术有一定了解者优先；</li>
<li><p>具备网站交互、页面设计、后台开发经验者优先。</p>
</li>
<li><p>简历投放地址：tgideas@qq.com</p>
</li>
<li>工作地点：深圳、上海</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-腾讯TGideas招聘高级视觉设计师、高级重构工程师 - 副本" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2013-01-08-腾讯TGideas招聘高级视觉设计师、高级重构工程师 - 副本.html" class="article-date">
      <time datetime="2013-01-08T03:56:27.000Z" itemprop="datePublished">2013-01-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2013-01-08-腾讯TGideas招聘高级视觉设计师、高级重构工程师 - 副本.html">腾讯TGideas招聘高级视觉设计师、高级重构工程师</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id=""><a href="#" class="headerlink" title=""></a><img src="wp-content/uploads/2013/01/TGideas-job-2013.jpg" alt=""></h2><div>你一手的好技法，却寻不着空间施展？</div><br><div>你满脑的妙点子，却找不到项目释放？</div><br><div>你浑身的游戏细菌，却碰不上神级队友结伴疯狂？</div><br><div>这里！TGideas！激情放纵的工作环境，热血恣肆的玩乐天堂，我们用多门类的专业人才已为你搭建好最专注的创作平台！</div><br><div>2013年，数款年度游戏巨作，诸多发展机会，只差设计强人！</div>

<h3 id="招聘岗位：高级视觉设计师（5名）"><a href="#招聘岗位：高级视觉设计师（5名）" class="headerlink" title="招聘岗位：高级视觉设计师（5名）"></a>招聘岗位：高级视觉设计师（5名）</h3><h4 id="岗位描述："><a href="#岗位描述：" class="headerlink" title="岗位描述："></a>岗位描述：</h4><p>隶属于腾讯公司互动娱乐业务系统市场部，负责游戏产品网站视觉表现以及其他相关推广类美术设计工作。</p>
<h4 id="职位要求："><a href="#职位要求：" class="headerlink" title="职位要求："></a>职位要求：</h4><ul>
<li>有较丰富游戏经验，熟悉国内外游戏行业动态，对游戏美术、动漫等领域有系统的了解，在游戏视觉表现力方面有较深认识；</li>
<li>同市场、产品相关人员讨论产品核心卖点，并给予有效的视觉设计策略支持，能够主导重点项目的视觉设计方向， 并完成主要视觉设计工作；</li>
<li>三年以上视觉设计从业经验；</li>
<li>有较好的专业知识广度，能够结合自身设计经验，根据业务需求推动方法论建设以及相关研究工作；</li>
<li>熟练操作相关设计软件（PS,AI），熟悉FLASH，Dreamweaver等软件者最佳；</li>
<li>良好的项目管理和沟通表达能力，对行业内的成本构成与业务规范有深入了解；</li>
<li>善于沟通，关注用户体验细节，有较强理解力与出色的沟通能力同时具备优秀的视觉表现能力。<br><div>简历投放地址：</div><br>tgideas@qq.com<br><div><br><div>工作地点：深圳、上海</div><div>

</div></div></li>
</ul>
<h3 id="招聘岗位：高级网页重构工程师（5名）"><a href="#招聘岗位：高级网页重构工程师（5名）" class="headerlink" title="招聘岗位：高级网页重构工程师（5名）"></a>招聘岗位：高级网页重构工程师（5名）</h3><h4 id="岗位描述：-1"><a href="#岗位描述：-1" class="headerlink" title="岗位描述："></a>岗位描述：</h4><p>隶属于腾讯公司互动娱乐业务系统市场部，负责游戏产品官网搭建、日常专题制作维护以及配合开发人员对功能型页面程序进行联调整合。</p>
<h4 id="职位要求：-1"><a href="#职位要求：-1" class="headerlink" title="职位要求："></a>职位要求：</h4><p><br></p>
<ul>
<li>从事3年以上网页重构工作，有相关行业经验者优先；</li>
<li>优秀的项目管理和沟通表达能力；</li>
<li>热爱游戏行业，能接受挑战并承受工作压力；</li>
<li>熟练使用DW，PS等网页制作及图片处理工具，并能手写代码；</li>
<li>精通XHTML语言和网页优化技巧，能快速构建出兼容主流浏览器的页面；</li>
<li>熟悉JS、JQ等前端开发语言，能完成基础的前端开发工作；</li>
<li>了解CGI、PHP等后台开发语言，能配合开发人员进行页面联调整合；</li>
<li>对于html5、css3、多终端等新技术有一定了解者优先；</li>
<li><p>具备网站交互、页面设计、后台开发经验者优先。</p>
</li>
<li><p>简历投放地址：tgideas@qq.com</p>
</li>
<li>工作地点：深圳、上海</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/23/">23</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2016 前端者
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的静态博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减双栏 Hexo 博客主题">Yelee</a> by MOxFIVE
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >本站到访数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 4;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>




<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>

<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>


    <script src="//cdn.bootcss.com/jqueryui/1.10.4/jquery-ui.min.js"></script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>